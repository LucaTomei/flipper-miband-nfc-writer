---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_logger.c ----
/**
 * @file miband_logger.c
 * @brief Logging implementation
 */

#include "miband_logger.h"
#include <furi_hal_rtc.h>
#include <stdarg.h>
#include <stdio.h>

#define TAG "MiBandLogger"

MiBandLogger* miband_logger_alloc(Storage* storage) {
    if(!storage) {
        FURI_LOG_E(TAG, "Storage is NULL!");
        return NULL;
    }

    MiBandLogger* logger = malloc(sizeof(MiBandLogger));
    if(!logger) {
        FURI_LOG_E(TAG, "Failed to allocate logger");
        return NULL;
    }

    logger->capacity = MAX_LOG_ENTRIES;
    logger->entries = malloc(sizeof(LogEntry) * logger->capacity);
    if(!logger->entries) {
        FURI_LOG_E(TAG, "Failed to allocate log entries");
        free(logger);
        return NULL;
    }

    logger->count = 0;
    logger->storage = storage;
    logger->enabled = true;

    // SAFE directory creation con check
    FS_Error err;

    err = storage_common_mkdir(storage, EXT_PATH("apps_data"));
    if(err != FSE_OK && err != FSE_EXIST) {
        FURI_LOG_W(TAG, "Failed to create apps_data: %d", err);
    }

    err = storage_common_mkdir(storage, EXT_PATH("apps_data/miband_nfc"));
    if(err != FSE_OK && err != FSE_EXIST) {
        FURI_LOG_W(TAG, "Failed to create miband_nfc dir: %d", err);
    }

    err = storage_common_mkdir(storage, LOG_PATH);
    if(err != FSE_OK && err != FSE_EXIST) {
        FURI_LOG_W(TAG, "Failed to create log dir: %d", err);
    }

    FURI_LOG_I(TAG, "Logger initialized");
    return logger;
}

void miband_logger_free(MiBandLogger* logger) {
    if(logger) {
        if(logger->entries) {
            free(logger->entries);
        }
        free(logger);
    }
}

void miband_logger_log(MiBandLogger* logger, LogLevel level, const char* format, ...) {
    if(!logger || !logger->enabled || !logger->entries) return;

    // Rotate if full
    if(logger->count >= logger->capacity) {
        // Remove oldest 25% entries
        size_t keep = logger->capacity * 3 / 4;
        memmove(
            logger->entries, logger->entries + (logger->count - keep), sizeof(LogEntry) * keep);
        logger->count = keep;
    }

    LogEntry* entry = &logger->entries[logger->count++];

    // Get timestamp
    furi_hal_rtc_get_datetime(&entry->timestamp);
    entry->level = level;

    // Format message
    va_list args;
    va_start(args, format);
    vsnprintf(entry->message, sizeof(entry->message), format, args);
    va_end(args);

    // Also log to FURI
    switch(level) {
    case LogLevelDebug:
        FURI_LOG_D(TAG, "%s", entry->message);
        break;
    case LogLevelInfo:
        FURI_LOG_I(TAG, "%s", entry->message);
        break;
    case LogLevelWarning:
        FURI_LOG_W(TAG, "%s", entry->message);
        break;
    case LogLevelError:
        FURI_LOG_E(TAG, "%s", entry->message);
        break;
    }
}

bool miband_logger_export(MiBandLogger* logger, const char* filename) {
    if(!logger || logger->count == 0) return false;

    FuriString* filepath = furi_string_alloc_printf("%s/%s", LOG_PATH, filename);
    File* file = storage_file_alloc(logger->storage);
    bool success = false;

    if(storage_file_open(file, furi_string_get_cstr(filepath), FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
        // Write header
        const char* header = "Mi Band NFC Writer - Log Export\n"
                             "================================\n\n";
        storage_file_write(file, header, strlen(header));

        // Write each entry
        for(size_t i = 0; i < logger->count; i++) {
            LogEntry* entry = &logger->entries[i];

            const char* level_str;
            switch(entry->level) {
            case LogLevelDebug:
                level_str = "DEBUG";
                break;
            case LogLevelInfo:
                level_str = "INFO ";
                break;
            case LogLevelWarning:
                level_str = "WARN ";
                break;
            case LogLevelError:
                level_str = "ERROR";
                break;
            default:
                level_str = "?????";
                break;
            }

            FuriString* line = furi_string_alloc_printf(
                "%04d-%02d-%02d %02d:%02d:%02d [%s] %s\n",
                entry->timestamp.year,
                entry->timestamp.month,
                entry->timestamp.day,
                entry->timestamp.hour,
                entry->timestamp.minute,
                entry->timestamp.second,
                level_str,
                entry->message);

            storage_file_write(file, furi_string_get_cstr(line), furi_string_size(line));
            furi_string_free(line);
        }

        storage_file_close(file);
        success = true;
        FURI_LOG_I(TAG, "Exported %zu log entries to %s", logger->count, filename);
    }

    storage_file_free(file);
    furi_string_free(filepath);
    return success;
}

void miband_logger_clear(MiBandLogger* logger) {
    if(logger) {
        logger->count = 0;
    }
}

size_t miband_logger_get_count(MiBandLogger* logger) {
    return logger ? logger->count : 0;
}

void miband_logger_set_enabled(MiBandLogger* logger, bool enabled) {
    if(logger) {
        logger->enabled = enabled;
    }
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_logger.h ----
/**
 * @file miband_logger.h
 * @brief Logging system with file export
 */

#pragma once

#include <furi.h>
#include <storage/storage.h>
#include <datetime/datetime.h>

#define LOG_PATH        EXT_PATH("apps_data/miband_nfc/logs")
#define MAX_LOG_ENTRIES 500
#define MAX_LOG_SIZE    50000 // 50KB max per file

typedef enum {
    LogLevelDebug,
    LogLevelInfo,
    LogLevelWarning,
    LogLevelError,
} LogLevel;

typedef struct {
    DateTime timestamp;
    LogLevel level;
    char message[128];
} LogEntry;

typedef struct {
    LogEntry* entries;
    size_t count;
    size_t capacity;
    Storage* storage;
    bool enabled;
} MiBandLogger;

/**
 * @brief Create logger instance
 */
MiBandLogger* miband_logger_alloc(Storage* storage);

/**
 * @brief Free logger instance
 */
void miband_logger_free(MiBandLogger* logger);

/**
 * @brief Add log entry
 */
void miband_logger_log(MiBandLogger* logger, LogLevel level, const char* format, ...);

/**
 * @brief Export logs to file
 */
bool miband_logger_export(MiBandLogger* logger, const char* filename);

/**
 * @brief Clear all logs
 */
void miband_logger_clear(MiBandLogger* logger);

/**
 * @brief Get log count
 */
size_t miband_logger_get_count(MiBandLogger* logger);

/**
 * @brief Enable/disable logging
 */
void miband_logger_set_enabled(MiBandLogger* logger, bool enabled);
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc.c ----
/**
 * @file miband_nfc.c
 * @brief Main application with FIXED memory management
 */

#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

bool miband_nfc_app_custom_event_callback(void* context, uint32_t event) {
    furi_assert(context);
    MiBandNfcApp* app = context;
    return scene_manager_handle_custom_event(app->scene_manager, event);
}

bool miband_nfc_app_back_event_callback(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;
    return scene_manager_handle_back_event(app->scene_manager);
}

static MiBandNfcApp* miband_nfc_app_alloc() {
    MiBandNfcApp* app = malloc(sizeof(MiBandNfcApp));

    // Initialize all pointers to NULL
    memset(app, 0, sizeof(MiBandNfcApp));

    // Open system records
    app->gui = furi_record_open(RECORD_GUI);
    app->notifications = furi_record_open(RECORD_NOTIFICATION);
    app->storage = furi_record_open(RECORD_STORAGE);
    app->dialogs = furi_record_open(RECORD_DIALOGS);
    FURI_LOG_I(TAG, "Records opened, storage=%p", app->storage); // Debug

    // Allocate view dispatcher and scene manager
    app->view_dispatcher = view_dispatcher_alloc();
    app->scene_manager = scene_manager_alloc(&miband_nfc_scene_handlers, app);

    view_dispatcher_set_event_callback_context(app->view_dispatcher, app);
    view_dispatcher_set_custom_event_callback(
        app->view_dispatcher, miband_nfc_app_custom_event_callback);
    view_dispatcher_set_navigation_event_callback(
        app->view_dispatcher, miband_nfc_app_back_event_callback);

    // Allocate and register views
    app->submenu = submenu_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdMainMenu, submenu_get_view(app->submenu));

    app->popup = popup_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdScanner, popup_get_view(app->popup));
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdMagicEmulator, popup_get_view(app->popup));
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdWriter, popup_get_view(app->popup));

    // ONE TextBox for both About and UID Report
    app->text_box = text_box_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdAbout, text_box_get_view(app->text_box));

    app->dialog_ex = dialog_ex_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdDialog, dialog_ex_get_view(app->dialog_ex));

    app->text_box_report = text_box_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, MiBandNfcViewIdUidReport, text_box_get_view(app->text_box_report));

    // Allocate NFC components
    app->nfc = nfc_alloc();
    app->nfc_device = nfc_device_alloc();
    app->target_data = mf_classic_alloc();
    app->mf_classic_data = mf_classic_alloc();

    // NFC poller/scanner/listener allocated on demand, initialized to NULL
    app->poller = NULL;
    app->scanner = NULL;
    app->listener = NULL;

    // Allocate string
    app->file_path = furi_string_alloc();

    // Initialize state
    app->is_valid_nfc_data = false;
    app->is_scan_active = false;
    app->last_selected_submenu_index = SubmenuIndexQuickUidCheck;
    app->current_operation = OperationTypeEmulateMagic;

    // Initialize state
    app->is_valid_nfc_data = false;
    app->is_scan_active = false;
    app->last_selected_submenu_index = SubmenuIndexQuickUidCheck;
    app->current_operation = OperationTypeEmulateMagic;

    app->logger = miband_logger_alloc(app->storage);

    // Load settings or use defaults
    if(!miband_settings_load(app)) {
        // Default settings
        app->auto_backup_enabled = true;
        app->verify_after_write = false;
        app->show_detailed_progress = true;
        app->enable_logging = true;
        FURI_LOG_I(TAG, "Using default settings");
    }
    miband_logger_set_enabled(app->logger, app->enable_logging);
    miband_logger_log(app->logger, LogLevelInfo, "Application started");
    app->temp_text_buffer = furi_string_alloc();

    return app;
}

static void miband_nfc_app_free(MiBandNfcApp* app) {
    furi_assert(app);

    // Free views and remove from dispatcher
    if(app->submenu) {
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdMainMenu);
        submenu_free(app->submenu);
    }

    if(app->popup) {
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdScanner);
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdMagicEmulator);
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdWriter);
        popup_free(app->popup);
    }

    if(app->text_box) {
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdAbout);
        text_box_free(app->text_box);
    }

    if(app->text_box_report) {
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdUidReport);
        text_box_free(app->text_box_report);
    }

    if(app->dialog_ex) {
        view_dispatcher_remove_view(app->view_dispatcher, MiBandNfcViewIdDialog);
        dialog_ex_free(app->dialog_ex);
    }

    // Free scene manager and view dispatcher
    if(app->scene_manager) {
        scene_manager_free(app->scene_manager);
    }

    if(app->view_dispatcher) {
        view_dispatcher_free(app->view_dispatcher);
    }

    // Stop and free NFC components if active
    if(app->listener) {
        nfc_listener_stop(app->listener);
        nfc_listener_free(app->listener);
    }

    if(app->poller) {
        nfc_poller_stop(app->poller);
        nfc_poller_free(app->poller);
    }

    if(app->scanner) {
        nfc_scanner_stop(app->scanner);
        nfc_scanner_free(app->scanner);
    }

    // Free NFC data structures
    if(app->nfc) {
        nfc_free(app->nfc);
    }

    if(app->nfc_device) {
        nfc_device_free(app->nfc_device);
    }

    if(app->mf_classic_data) {
        mf_classic_free(app->mf_classic_data);
    }

    if(app->target_data) {
        mf_classic_free(app->target_data);
    }

    // Free string
    if(app->file_path) {
        furi_string_free(app->file_path);
    }

    // Close system records
    if(app->dialogs) {
        furi_record_close(RECORD_DIALOGS);
    }

    if(app->storage) {
        furi_record_close(RECORD_STORAGE);
    }

    if(app->notifications) {
        furi_record_close(RECORD_NOTIFICATION);
    }

    if(app->gui) {
        furi_record_close(RECORD_GUI);
    }

    if(app->logger) {
        miband_logger_log(app->logger, LogLevelInfo, "Application closing");
        miband_logger_free(app->logger);
    }
    if(app->temp_text_buffer) {
        furi_string_free(app->temp_text_buffer);
    }
    // Finally free app structure
    free(app);
}

int32_t miband_nfc_app(void* p) {
    UNUSED(p);

    MiBandNfcApp* app = miband_nfc_app_alloc();

    view_dispatcher_attach_to_gui(app->view_dispatcher, app->gui, ViewDispatcherTypeFullscreen);
    scene_manager_next_scene(app->scene_manager, MiBandNfcSceneMainMenu);
    view_dispatcher_run(app->view_dispatcher);

    miband_nfc_app_free(app);

    return 0;
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc.h ----
/**
 * @file miband_nfc.h
 * @brief Public header for Mi Band NFC Writer application
 * 
 * This is the main public header file for the Mi Band NFC Writer application.
 * It defines the opaque application structure type that is used throughout
 * the codebase.
 * 
 * The actual structure definition is in miband_nfc_i.h (internal header)
 * to maintain encapsulation and prevent external code from directly
 * accessing internal application state.
 */

#pragma once

/**
 * @brief Opaque application structure
 * 
 * This forward declaration creates an opaque type for the application structure.
 * External code can hold pointers to MiBandNfcApp but cannot access its
 * internal members directly.
 * 
 * The full structure definition is in miband_nfc_i.h and includes:
 * - GUI components (view dispatcher, scene manager, views)
 * - NFC components (scanner, poller, listener)
 * - Application state (loaded data, current operation, etc.)
 * 
 * This pattern provides encapsulation and allows the internal structure
 * to change without affecting external code.
 */
typedef struct MiBandNfcApp MiBandNfcApp;
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_i.h ----
/**
 * @file miband_nfc_i.h
 * @brief Internal header - Updated with new features
 */

#pragma once

#include <furi.h>
#include <dialogs/dialogs.h>
#include <gui/gui.h>
#include <gui/scene_manager.h>
#include <gui/modules/submenu.h>
#include <gui/modules/popup.h>
#include <gui/modules/dialog_ex.h>
#include <gui/modules/text_box.h>
#include <gui/view_dispatcher.h>
#include <notification/notification_messages.h>
#include <nfc/nfc.h>
#include <nfc/nfc_device.h>
#include <nfc/nfc_scanner.h>
#include <nfc/nfc_poller.h>
#include <nfc/nfc_listener.h>
#include <nfc/protocols/mf_classic/mf_classic.h>
#include <lib/nfc/protocols/mf_classic/mf_classic_poller.h>
#include <nfc/protocols/mf_classic/mf_classic_poller_sync.h>
#include <nfc/protocols/mf_classic/mf_classic_listener.h>
#include <nfc/protocols/iso14443_3a/iso14443_3a_poller_sync.h>
#include <storage/storage.h>

#include <furi_hal_rtc.h>
#include "miband_nfc.h"
#include "miband_nfc_icons.h"
#include "miband_nfc_scene.h"
#include "progress_tracker.h"
#include "miband_logger.h"

#define NFC_APP_FOLDER    EXT_PATH("nfc")
#define NFC_APP_EXTENSION ".nfc"

typedef enum {
    MiBandNfcViewIdMainMenu, // 0
    MiBandNfcViewIdScanner, // 1
    MiBandNfcViewIdMagicEmulator, // 2
    MiBandNfcViewIdWriter, // 3
    MiBandNfcViewIdFileSelect, // 4
    MiBandNfcViewIdAbout, // 5
    MiBandNfcViewIdUidReport, // 6
    MiBandNfcViewIdDialog, // 7
} MiBandNfcViewId;

/**
 * @brief Menu item indices
 */
typedef enum {
    SubmenuIndexQuickUidCheck = 0,
    SubmenuIndexEmulateNfcMagic,
    SubmenuIndexWriteOriginalData,
    SubmenuIndexSaveMagic,
    SubmenuIndexVerify,
    SubmenuIndexSettings,
    SubmenuIndexAbout,
} SubmenuIndex;

typedef enum {
    SettingsIndexAutoBackup = 0,
    SettingsIndexVerifyAfterWrite,
    SettingsIndexShowProgress,
    SettingsIndexEnableLogging,
    SettingsIndexExportLogs,
    SettingsIndexClearLogs,
    SettingsIndexBack,
} SettingsIndex;

enum MiBandNfcCustomEvent {
    MiBandNfcCustomEventCardDetected,
    MiBandNfcCustomEventCardLost,
    MiBandNfcCustomEventMfClassicCard,
    MiBandNfcCustomEventPollerDone,
    MiBandNfcCustomEventWrongCard,
    MiBandNfcCustomEventViewExit,
    MiBandNfcCustomEventPollerFailed,
    MiBandNfcCustomEventVerifyExit,
    MiBandNfcCustomEventVerifyViewDetails,
};

typedef enum {
    OperationTypeEmulateMagic,
    OperationTypeWriteOriginal,
    OperationTypeSaveMagic,
    OperationTypeVerify,
} OperationType;

struct MiBandNfcApp {
    // GUI components
    Gui* gui;
    SceneManager* scene_manager;
    ViewDispatcher* view_dispatcher;
    NotificationApp* notifications;

    // Views
    Submenu* submenu;
    Popup* popup;
    TextBox* text_box; // Shared by About and UID Check
    TextBox* text_box_report;
    DialogEx* dialog_ex;

    // File handling
    DialogsApp* dialogs;
    Storage* storage;
    FuriString* file_path;

    MiBandLogger* logger;

    // Settings
    bool auto_backup_enabled;
    bool verify_after_write;
    bool show_detailed_progress;
    bool enable_logging;

    // NFC components (allocated on demand)
    Nfc* nfc;
    NfcScanner* scanner;
    NfcPoller* poller;
    NfcListener* listener;
    NfcDevice* nfc_device;

    // NFC data
    MfClassicData* target_data; // Data read from physical card
    MfClassicData* mf_classic_data; // Data loaded from file

    // State
    bool is_valid_nfc_data;
    bool is_scan_active;
    SubmenuIndex last_selected_submenu_index;
    OperationType current_operation;

    FuriString* temp_text_buffer;
};

bool miband_settings_save(MiBandNfcApp* app);
bool miband_settings_load(MiBandNfcApp* app);
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene.c ----
#include "miband_nfc_scene.h"

// Generate scene on_enter handlers array
void (*const miband_nfc_on_enter_handlers[])(void*) = {
#define ADD_SCENE(prefix, name, id) prefix##_scene_##name##_on_enter,
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE
};

// Generate scene on_event handlers array
bool (*const miband_nfc_on_event_handlers[])(void* context, SceneManagerEvent event) = {
#define ADD_SCENE(prefix, name, id) prefix##_scene_##name##_on_event,
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE
};

// Generate scene on_exit handlers array
void (*const miband_nfc_on_exit_handlers[])(void* context) = {
#define ADD_SCENE(prefix, name, id) prefix##_scene_##name##_on_exit,
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE
};

// Initialize scene handlers configuration
const SceneManagerHandlers miband_nfc_scene_handlers = {
    .on_enter_handlers = miband_nfc_on_enter_handlers,
    .on_event_handlers = miband_nfc_on_event_handlers,
    .on_exit_handlers = miband_nfc_on_exit_handlers,
    .scene_num = MiBandNfcSceneNum,
};
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene.h ----
/**
 * @file miband_nfc_scene.h
 * @brief Scene manager declarations and scene ID enumeration
 * 
 * This file declares all scene handler functions and defines the scene ID
 * enumeration using the X-Macro pattern. Each scene has three handlers:
 * - on_enter: Called when entering the scene
 * - on_event: Called to handle events while in the scene
 * - on_exit: Called when leaving the scene
 */

#pragma once

#include <gui/scene_manager.h>

/**
 * Generate scene on_enter handler declarations
 * 
 * Creates declarations like:
 * void miband_nfc_scene_main_menu_on_enter(void*);
 * void miband_nfc_scene_file_select_on_enter(void*);
 * etc.
 */
#define ADD_SCENE(prefix, name, id) void prefix##_scene_##name##_on_enter(void*);
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE

/**
 * Generate scene on_event handler declarations
 * 
 * Creates declarations like:
 * bool miband_nfc_scene_main_menu_on_event(void* context, SceneManagerEvent event);
 * bool miband_nfc_scene_file_select_on_event(void* context, SceneManagerEvent event);
 * etc.
 * 
 * Returns true if the event was consumed, false otherwise.
 */
#define ADD_SCENE(prefix, name, id) \
    bool prefix##_scene_##name##_on_event(void* context, SceneManagerEvent event);
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE

/**
 * Generate scene on_exit handler declarations
 * 
 * Creates declarations like:
 * void miband_nfc_scene_main_menu_on_exit(void* context);
 * void miband_nfc_scene_file_select_on_exit(void* context);
 * etc.
 */
#define ADD_SCENE(prefix, name, id) void prefix##_scene_##name##_on_exit(void* context);
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE

/**
 * Scene handlers structure
 * 
 * This structure contains arrays of function pointers for all scene handlers.
 * It is used by the scene manager to call the appropriate handlers.
 */
extern const SceneManagerHandlers miband_nfc_scene_handlers;

/**
 * Scene ID enumeration
 * 
 * Each scene has a unique ID used by the scene manager to identify
 * and switch between scenes.
 * 
 * Generated from miband_nfc_scene_config.h using the X-Macro pattern.
 * Creates enum values like:
 * - MiBandNfcSceneMainMenu
 * - MiBandNfcSceneFileSelect
 * - MiBandNfcSceneMagicEmulator
 * etc.
 * 
 * MiBandNfcSceneNum is automatically set to the total number of scenes.
 */
typedef enum {
#define ADD_SCENE(prefix, name, id) MiBandNfcScene##id,
#include "miband_nfc_scene_config.h"
#undef ADD_SCENE
    MiBandNfcSceneNum, // Total number of scenes
} MiBandNfcScene;
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_about.c ----
/**
 * @file miband_nfc_scene_about.c
 * @brief About/Help information scene
 * 
 * This scene displays comprehensive documentation about the application,
 * including features, operations, troubleshooting tips, and usage instructions.
 * Uses a scrollable TextBox to display all information.
 */

#include "miband_nfc_i.h"

/**
 * @brief Scene entry point
 * 
 * Sets up the TextBox with comprehensive help text and displays it.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_about_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    // Set comprehensive help text
    text_box_set_text(
        app->text_box,
        "Mi Band NFC Writer v1.0\n"
        "========================\n\n"

        "FEATURES:\n"
        "- Load NFC-A dumps from /nfc folder\n"
        "- Emulate Magic Card template for Mi Band\n"
        "- Write original data to Mi Band NFC\n"
        "- Verify written data integrity\n"
        "- Save dumps with magic keys (0xFF)\n\n"

        "OPERATIONS:\n\n"

        "1. EMULATE MAGIC CARD:\n"
        "   Creates a blank template with:\n"
        "   - Original UID preserved\n"
        "   - All data blocks zeroed\n"
        "   - All keys set to FF FF FF FF FF FF\n"
        "   - Magic card access bits\n"
        "   Use this to prepare Mi Band for writing\n\n"

        "2. WRITE ORIGINAL DATA:\n"
        "   Writes actual dump data to Mi Band:\n"
        "   - Tries dump keys first\n"
        "   - Falls back to 0xFF keys if needed\n"
        "   - Preserves UID block (read-only)\n"
        "   - Includes all data + sector trailers\n"
        "   - Real-time progress feedback\n\n"

        "3. SAVE MAGIC DUMP:\n"
        "   Converts dump for magic card use:\n"
        "   - Changes all keys to 0xFF\n"
        "   - Sets magic access bits\n"
        "   - Saves with '_magic' suffix\n"
        "   - Compatible with magic card writers\n\n"

        "4. VERIFY WRITE:\n"
        "   Checks if write was successful:\n"
        "   - Reads Mi Band with dump keys\n"
        "   - Compares all data blocks\n"
        "   - Reports differences found\n\n"

        "TROUBLESHOOTING:\n\n"

        "Write Fails:\n"
        "- Ensure card is magic card type\n"
        "- Check card positioning\n"
        "- Try emulate magic template first\n\n"

        "USAGE TIPS:\n"
        "- Always backup original dumps\n"
        "- Position cards carefully\n"
        "- Use verify after writing\n\n"

        "For support and updates:\n"
        "Check Flipper Zero community forums\n\n"

        "Press Back to return to main menu.");

    // Use text font for better readability
    text_box_set_font(app->text_box, TextBoxFontText);

    // Start at the beginning of the text
    text_box_set_focus(app->text_box, TextBoxFocusStart);

    // Switch to text box view
    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdAbout);
}

/**
 * @brief Scene event handler
 * 
 * Handles back button press to return to main menu.
 * 
 * @param context Pointer to MiBandNfcApp instance
 * @param event Scene manager event
 * @return true if event was consumed, false otherwise
 */
bool miband_nfc_scene_about_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeBack) {
        // User pressed back - return to main menu
        scene_manager_previous_scene(app->scene_manager);
        consumed = true;
    }

    return consumed;
}

/**
 * @brief Scene exit handler
 * 
 * Resets the TextBox when leaving the scene.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_about_on_exit(void* context) {
    MiBandNfcApp* app = context;
    text_box_reset(app->text_box);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_backup.c ----
/**
 * @file miband_nfc_scene_backup.c
 * @brief Automatic backup before write operations
 * 
 * This scene automatically backs up the current Mi Band data before
 * performing write operations. Creates backups in /ext/nfc/backups/
 * with timestamp for easy restoration.
 */

#include "miband_nfc_i.h"
#include <datetime/datetime.h>

#define TAG           "MiBandNfc"
#define BACKUP_FOLDER EXT_PATH("nfc/backups")

/**
 * @brief Create backup directory if it doesn't exist
 * 
 * @param storage Storage API instance
 * @return true if directory exists or was created successfully
 */
static bool ensure_backup_directory(Storage* storage) {
    if(!storage_simply_mkdir(storage, BACKUP_FOLDER)) {
        // Check if it already exists
        FileInfo file_info;
        if(storage_common_stat(storage, BACKUP_FOLDER, &file_info) == FSE_OK) {
            return file_info.flags & FSF_DIRECTORY;
        }
        return false;
    }
    return true;
}

/**
 * @brief Read all data from Mi Band using multiple key strategies
 * 
 * @param app Pointer to MiBandNfcApp instance
 * @return true if all sectors read successfully
 */
static bool backup_read_all_data(MiBandNfcApp* app) {
    size_t total_sectors = mf_classic_get_total_sectors_num(app->mf_classic_data->type);

    popup_set_text(app->popup, "Reading Mi Band...\n\nSector 0/16", 64, 22, AlignCenter, AlignTop);

    for(size_t sector = 0; sector < total_sectors; sector++) {
        uint8_t first_block = mf_classic_get_first_block_num_of_sector(sector);
        uint8_t blocks_in_sector = mf_classic_get_blocks_num_in_sector(sector);

        if(sector % 2 == 0) {
            FuriString* progress = furi_string_alloc();
            furi_string_printf(
                progress, "Reading...\nSector %zu/%zu\n\n", sector + 1, total_sectors);

            uint32_t percent = ((sector + 1) * 100) / total_sectors;
            furi_string_cat_str(progress, "[");
            for(uint8_t i = 0; i < 20; i++) {
                if(i < (percent / 5))
                    furi_string_cat_str(progress, "=");
                else
                    furi_string_cat_str(progress, " ");
            }
            furi_string_cat_printf(progress, "]\n%lu%%", percent);

            popup_set_text(
                app->popup, furi_string_get_cstr(progress), 64, 18, AlignCenter, AlignTop);
            furi_string_free(progress);
        }

        furi_delay_ms(50);

        MfClassicKey keys_to_try[3];
        MfClassicKeyType key_types[3];
        int keys_count = 0;

        MfClassicSectorTrailer* sec_tr =
            mf_classic_get_sector_trailer_by_sector(app->mf_classic_data, sector);

        if(sec_tr && mf_classic_is_key_found(app->mf_classic_data, sector, MfClassicKeyTypeA)) {
            memcpy(keys_to_try[keys_count].data, sec_tr->key_a.data, 6);
            key_types[keys_count] = MfClassicKeyTypeA;
            keys_count++;
        }

        if(sec_tr && mf_classic_is_key_found(app->mf_classic_data, sector, MfClassicKeyTypeB)) {
            memcpy(keys_to_try[keys_count].data, sec_tr->key_b.data, 6);
            key_types[keys_count] = MfClassicKeyTypeB;
            keys_count++;
        }

        memset(keys_to_try[keys_count].data, 0xFF, 6);
        key_types[keys_count] = MfClassicKeyTypeA;
        keys_count++;

        bool sector_read = false;
        for(int key_idx = 0; key_idx < keys_count && !sector_read; key_idx++) {
            MfClassicAuthContext auth_context;
            MfClassicError error = mf_classic_poller_sync_auth(
                app->nfc, first_block, &keys_to_try[key_idx], key_types[key_idx], &auth_context);

            if(error == MfClassicErrorNone) {
                bool all_read = true;
                for(uint8_t block_in_sector = 0; block_in_sector < blocks_in_sector;
                    block_in_sector++) {
                    size_t block_idx = first_block + block_in_sector;

                    error = mf_classic_poller_sync_read_block(
                        app->nfc,
                        block_idx,
                        &keys_to_try[key_idx],
                        key_types[key_idx],
                        &app->target_data->block[block_idx]);

                    if(error != MfClassicErrorNone) {
                        all_read = false;
                        break;
                    }
                }

                if(all_read) {
                    sector_read = true;
                    FURI_BIT_SET(app->target_data->key_a_mask, sector);
                    FURI_BIT_SET(app->target_data->key_b_mask, sector);
                }
            }
        }

        if(!sector_read) {
            FURI_LOG_W(TAG, "Failed to read sector %zu for backup", sector);
            return false;
        }

        furi_delay_ms(50);
    }

    return true;
}

/**
 * @brief Scene entry point - performs backup operation
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_backup_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    popup_reset(app->popup);
    popup_set_header(app->popup, "Creating Backup", 64, 4, AlignCenter, AlignTop);
    popup_set_text(
        app->popup, "Place Mi Band near\nFlipper Zero...", 64, 22, AlignCenter, AlignTop);

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);
    notification_message(app->notifications, &sequence_blink_start_cyan);

    if(!ensure_backup_directory(app->storage)) {
        notification_message(app->notifications, &sequence_error);
        popup_set_header(app->popup, "Backup Failed", 64, 4, AlignCenter, AlignTop);
        popup_set_text(app->popup, "Cannot create\nbackup folder", 64, 22, AlignCenter, AlignTop);
        furi_delay_ms(2000);
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    mf_classic_reset(app->target_data);
    app->target_data->type = app->mf_classic_data->type;

    popup_set_text(app->popup, "Detecting card...", 64, 30, AlignCenter, AlignTop);

    MfClassicType detected_type;
    if(mf_classic_poller_sync_detect_type(app->nfc, &detected_type) != MfClassicErrorNone) {
        notification_message(app->notifications, &sequence_error);
        popup_set_header(app->popup, "Card Not Found", 64, 4, AlignCenter, AlignTop);
        popup_set_text(app->popup, "Place card near\nFlipper Zero", 64, 22, AlignCenter, AlignTop);
        furi_delay_ms(2000);
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    if(!backup_read_all_data(app)) {
        notification_message(app->notifications, &sequence_error);
        popup_set_header(app->popup, "Read Failed", 64, 4, AlignCenter, AlignTop);
        popup_set_text(app->popup, "Cannot read\nall sectors", 64, 22, AlignCenter, AlignTop);
        furi_delay_ms(2000);
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    DateTime datetime;
    furi_hal_rtc_get_datetime(&datetime);

    FuriString* backup_path = furi_string_alloc_printf(
        "%s/backup_%04d%02d%02d_%02d%02d%02d.nfc",
        BACKUP_FOLDER,
        datetime.year,
        datetime.month,
        datetime.day,
        datetime.hour,
        datetime.minute,
        datetime.second);

    popup_set_text(app->popup, "Saving backup...", 64, 30, AlignCenter, AlignTop);

    nfc_device_set_data(app->nfc_device, NfcProtocolMfClassic, app->target_data);
    bool save_success = nfc_device_save(app->nfc_device, furi_string_get_cstr(backup_path));
    nfc_device_set_data(app->nfc_device, NfcProtocolMfClassic, app->mf_classic_data);

    popup_reset(app->popup);

    if(save_success) {
        notification_message(app->notifications, &sequence_success);
        popup_set_header(app->popup, "Backup Created!", 64, 4, AlignCenter, AlignTop);

        FuriString* msg = furi_string_alloc_printf(
            "Saved to:\nbackups/backup_%04d%02d%02d\n_%02d%02d%02d.nfc",
            datetime.year,
            datetime.month,
            datetime.day,
            datetime.hour,
            datetime.minute,
            datetime.second);

        popup_set_text(app->popup, furi_string_get_cstr(msg), 4, 18, AlignLeft, AlignTop);
        popup_set_icon(app->popup, 90, 20, &I_DolphinSuccess_91x55);

        furi_string_free(msg);
        FURI_LOG_I(TAG, "Backup saved: %s", furi_string_get_cstr(backup_path));
    } else {
        notification_message(app->notifications, &sequence_error);
        popup_set_header(app->popup, "Save Failed", 64, 4, AlignCenter, AlignTop);
        popup_set_text(app->popup, "Cannot save\nbackup file", 64, 22, AlignCenter, AlignTop);
        popup_set_icon(app->popup, 40, 28, &I_WarningDolphinFlip_45x42);
        FURI_LOG_E(TAG, "Failed to save backup");
    }

    furi_string_free(backup_path);
    furi_delay_ms(3000);

    scene_manager_next_scene(app->scene_manager, MiBandNfcSceneWriter);
}

/**
 * @brief Scene event handler
 */
bool miband_nfc_scene_backup_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false;
}

/**
 * @brief Scene exit handler
 */
void miband_nfc_scene_backup_on_exit(void* context) {
    MiBandNfcApp* app = context;
    notification_message(app->notifications, &sequence_blink_stop);
    popup_reset(app->popup);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_config.h ----
/**
 * @file miband_nfc_scene_config.h
 * @brief Scene configuration - Updated with new features
 */

// Main menu - entry point of the application
ADD_SCENE(miband_nfc, main_menu, MainMenu)

// File selection - browse and select NFC dump files
ADD_SCENE(miband_nfc, file_select, FileSelect)

// Magic card emulation - emulate blank template with 0xFF keys
ADD_SCENE(miband_nfc, magic_emulator, MagicEmulator)

// Scanner - detect and identify NFC cards
ADD_SCENE(miband_nfc, scanner, Scanner)

// Backup - automatic backup before write (NEW)
ADD_SCENE(miband_nfc, backup, Backup)

// Writer - write dump data to Mi Band NFC
ADD_SCENE(miband_nfc, writer, Writer)

// Magic saver - convert and save dump with magic keys
ADD_SCENE(miband_nfc, magic_saver, MagicSaver)

// Verify - read and compare data with original dump
ADD_SCENE(miband_nfc, verify, Verify)

// Difference viewer - show detailed verification differences (NEW)
ADD_SCENE(miband_nfc, diff_viewer, DiffViewer)

// UID Check - quick UID display with disk scanner (NEW)
ADD_SCENE(miband_nfc, uid_check, UidCheck)

// About - display help and usage information
ADD_SCENE(miband_nfc, about, About)

ADD_SCENE(miband_nfc, settings, Settings)
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_diff_viewer.c ----
/**
 * @file miband_nfc_scene_diff_viewer.c
 * @brief Detailed difference viewer - FIXED
 */

#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

typedef struct {
    size_t block_index;
    uint8_t expected[16];
    uint8_t found[16];
    uint8_t diff_mask[16];
    uint8_t diff_count;
} BlockDifference;

static void format_hex_with_diff(
    FuriString* output,
    const uint8_t* data,
    const uint8_t* mask,
    size_t length) {
    for(size_t i = 0; i < length; i++) {
        if(mask && mask[i]) {
            furi_string_cat_printf(output, "[%02X]", data[i]);
        } else {
            furi_string_cat_printf(output, " %02X ", data[i]);
        }
        if((i + 1) % 8 == 0 && i < length - 1) {
            furi_string_cat_str(output, "\n     ");
        }
    }
}

static FuriString*
    generate_difference_report(MiBandNfcApp* app, BlockDifference* differences, size_t diff_count) {
    FuriString* report = furi_string_alloc();
    if(!report) return NULL;

    size_t total_blocks = mf_classic_get_total_block_num(app->mf_classic_data->type);

    furi_string_printf(
        report,
        "Verification Results\n"
        "====================\n\n"
        "Total Blocks: %zu\n"
        "Blocks OK: %zu\n"
        "Blocks DIFFER: %zu\n\n",
        total_blocks,
        total_blocks - diff_count,
        diff_count);

    if(diff_count == 0) {
        furi_string_cat_str(report, "All blocks match!\n\n");
        furi_string_cat_str(report, "Press Back to exit");
        return report;
    }

    furi_string_cat_str(report, "Differences:\n");
    furi_string_cat_str(report, "============\n\n");

    for(size_t i = 0; i < diff_count && i < 10; i++) {
        BlockDifference* diff = &differences[i];

        const char* block_type = "Data";
        if(diff->block_index == 0) {
            block_type = "UID";
        } else if(mf_classic_is_sector_trailer(diff->block_index)) {
            block_type = "Trailer";
        }

        furi_string_cat_printf(
            report,
            "Block %zu (%s)\n%u bytes differ\n",
            diff->block_index,
            block_type,
            diff->diff_count);

        furi_string_cat_str(report, "Exp: ");
        format_hex_with_diff(report, diff->expected, diff->diff_mask, 16);
        furi_string_cat_str(report, "\n");

        furi_string_cat_str(report, "Got: ");
        format_hex_with_diff(report, diff->found, diff->diff_mask, 16);
        furi_string_cat_str(report, "\n\n");
    }

    if(diff_count > 10) {
        furi_string_cat_printf(report, "... %zu more\n\n", diff_count - 10);
    }

    furi_string_cat_str(report, "[XX]=diff  XX=same\n\nPress Back");
    return report;
}

void miband_nfc_scene_diff_viewer_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    // Reset buffer
    furi_string_reset(app->temp_text_buffer);

    popup_reset(app->popup);
    dialog_ex_reset(app->dialog_ex);

    if(!app->is_valid_nfc_data) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    size_t total_blocks = mf_classic_get_total_block_num(app->mf_classic_data->type);

    BlockDifference* differences = malloc(sizeof(BlockDifference) * total_blocks);
    if(!differences) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    size_t diff_count = 0;

    for(size_t i = 0; i < total_blocks; i++) {
        if(i == 0 || mf_classic_is_sector_trailer(i)) continue;

        bool blocks_differ = false;
        uint8_t diff_mask[16] = {0};
        uint8_t diff_bytes = 0;

        for(size_t j = 0; j < 16; j++) {
            if(app->mf_classic_data->block[i].data[j] != app->target_data->block[i].data[j]) {
                blocks_differ = true;
                diff_mask[j] = 1;
                diff_bytes++;
            }
        }

        if(blocks_differ) {
            if(diff_count >= total_blocks) {
                FURI_LOG_E(TAG, "Diff count overflow!");
                break;
            }

            differences[diff_count].block_index = i;
            differences[diff_count].diff_count = diff_bytes;
            memcpy(differences[diff_count].expected, app->mf_classic_data->block[i].data, 16);
            memcpy(differences[diff_count].found, app->target_data->block[i].data, 16);
            memcpy(differences[diff_count].diff_mask, diff_mask, 16);
            diff_count++;
        }
    }

    FuriString* report = generate_difference_report(app, differences, diff_count);
    free(differences);

    if(!report) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    furi_string_set(app->temp_text_buffer, report);
    furi_string_free(report);

    text_box_reset(app->text_box_report);
    text_box_set_text(app->text_box_report, furi_string_get_cstr(app->temp_text_buffer));
    text_box_set_font(app->text_box_report, TextBoxFontText);
    text_box_set_focus(app->text_box_report, TextBoxFocusStart);

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdUidReport);
}

bool miband_nfc_scene_diff_viewer_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;

    if(event.type == SceneManagerEventTypeBack) {
        scene_manager_search_and_switch_to_another_scene(
            app->scene_manager, MiBandNfcSceneMainMenu);
        return true;
    }
    return false;
}

void miband_nfc_scene_diff_viewer_on_exit(void* context) {
    MiBandNfcApp* app = context;
    text_box_reset(app->text_box_report);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_file_select.c ----
/**
 * @file miband_nfc_scene_file_select.c
 * @brief File selection with loading feedback
 */

#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

void miband_nfc_scene_file_select_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    furi_string_set(app->file_path, NFC_APP_FOLDER);
    mf_classic_reset(app->mf_classic_data);

    if(!storage_simply_mkdir(app->storage, NFC_APP_FOLDER)) {
        FURI_LOG_W(TAG, "Failed to create NFC directory, continuing anyway");
    }

    DialogsFileBrowserOptions browser_options;
    dialog_file_browser_set_basic_options(&browser_options, NFC_APP_EXTENSION, &I_Nfc_10px);
    browser_options.base_path = NFC_APP_FOLDER;
    browser_options.hide_dot_files = true;
    browser_options.skip_assets = false;

    if(!dialog_file_browser_show(app->dialogs, app->file_path, app->file_path, &browser_options)) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    FURI_LOG_D(TAG, "File selected: %s", furi_string_get_cstr(app->file_path));

    // Show loading popup
    popup_reset(app->popup);
    popup_set_header(app->popup, "Loading...", 64, 4, AlignCenter, AlignTop);
    popup_set_text(app->popup, "Reading file", 64, 30, AlignCenter, AlignTop);
    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);
    furi_delay_ms(100); // Show loading message

    if(nfc_device_load(app->nfc_device, furi_string_get_cstr(app->file_path))) {
        FURI_LOG_D(TAG, "Loaded file: %s", furi_string_get_cstr(app->file_path));

        if(nfc_device_get_protocol(app->nfc_device) == NfcProtocolMfClassic) {
            const MfClassicData* loaded_data =
                nfc_device_get_data(app->nfc_device, NfcProtocolMfClassic);

            if(loaded_data == NULL) {
                FURI_LOG_E(TAG, "Failed to get MfClassic data from loaded file");
                popup_set_text(app->popup, "Invalid data", 64, 30, AlignCenter, AlignTop);
                furi_delay_ms(1000);
                scene_manager_previous_scene(app->scene_manager);
                return;
            }

            mf_classic_copy(app->mf_classic_data, loaded_data);
            app->is_valid_nfc_data = true;

            popup_set_text(app->popup, "File loaded!", 64, 30, AlignCenter, AlignTop);
            furi_delay_ms(500);

            switch(app->current_operation) {
            case OperationTypeEmulateMagic:
                scene_manager_next_scene(app->scene_manager, MiBandNfcSceneMagicEmulator);
                break;
            case OperationTypeWriteOriginal:
                if(app->auto_backup_enabled) {
                    scene_manager_next_scene(app->scene_manager, MiBandNfcSceneBackup);
                } else {
                    scene_manager_next_scene(app->scene_manager, MiBandNfcSceneWriter);
                }
                break;
            case OperationTypeSaveMagic:
                scene_manager_next_scene(app->scene_manager, MiBandNfcSceneMagicSaver);
                break;
            case OperationTypeVerify:
                scene_manager_next_scene(app->scene_manager, MiBandNfcSceneVerify);
                break;
            default:
                scene_manager_previous_scene(app->scene_manager);
                break;
            }
        } else {
            FURI_LOG_W(TAG, "File is not Mifare Classic protocol.");
            popup_set_text(app->popup, "Not MF Classic", 64, 30, AlignCenter, AlignTop);
            furi_delay_ms(1000);
            scene_manager_previous_scene(app->scene_manager);
        }
    } else {
        FURI_LOG_E(TAG, "Failed to load file: %s", furi_string_get_cstr(app->file_path));
        popup_set_text(app->popup, "Load failed", 64, 30, AlignCenter, AlignTop);
        furi_delay_ms(1000);
        scene_manager_previous_scene(app->scene_manager);
    }
}

bool miband_nfc_scene_file_select_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeBack) {
        consumed = scene_manager_previous_scene(app->scene_manager);
    }
    return consumed;
}

void miband_nfc_scene_file_select_on_exit(void* context) {
    MiBandNfcApp* app = context;
    popup_reset(app->popup);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_magic_emulator.c ----
/**
 * @file miband_nfc_scene_magic_emulator.c
 * @brief Magic card emulation scene
 * 
 * This scene emulates a "blank" Mifare Classic card with all data blocks zeroed
 * and all keys set to 0xFF (magic card format). This prepares the Mi Band NFC
 * for writing by creating a template that can be authenticated with magic keys.
 * 
 * The emulation preserves the original UID from the dump file and sets up
 * sector trailers with magic access bits that allow easy read/write access.
 */

#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

/**
 * @brief Emulation statistics tracker
 * 
 * Tracks authentication attempts, reader connections, and other metrics
 * during emulation to provide real-time feedback to the user.
 */
typedef struct {
    uint32_t auth_attempts; // Total authentication attempts
    uint32_t successful_auths; // Successful authentications
    uint32_t failed_auths; // Failed authentications
    uint32_t reader_connections; // Number of times reader connected
    uint32_t data_reads; // Number of data block reads
    FuriString* last_activity; // Description of last activity
    FuriString* status_message; // Current status message
    bool is_active; // True if emulation is running
    FuriTimer* update_timer; // Timer for periodic UI updates
} EmulationStats;

static EmulationStats* emulation_stats = NULL;

/**
 * @brief Timer callback for periodic UI updates
 * 
 * Called every second to refresh the emulation statistics display.
 * Shows connection count, authentication stats, and current status.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
static void emulation_timer_callback(void* context) {
    MiBandNfcApp* app = context;
    if(emulation_stats && emulation_stats->is_active) {
        popup_reset(app->popup);

        popup_set_header(app->popup, "Magic Template Active", 64, 2, AlignCenter, AlignTop);

        FuriString* stats_text = furi_string_alloc();
        furi_string_printf(stats_text, "UID+0xFF template\n");
        // furi_string_cat_printf(
        //     stats_text, "Connections: %lu\n", emulation_stats->reader_connections);
        furi_string_cat_printf(
            stats_text,
            "Auth: %lu | OK %lu\n",
            emulation_stats->auth_attempts,
            emulation_stats->successful_auths);
        // furi_string_cat_printf(stats_text, "  Success: %lu\n", emulation_stats->successful_auths);
        // furi_string_cat_printf(stats_text, "  Failed: %lu\n", emulation_stats->failed_auths);
        // furi_string_cat_printf(stats_text, "Data reads: %lu\n", emulation_stats->data_reads);

        if(furi_string_size(emulation_stats->last_activity) > 0) {
            furi_string_cat_printf(
                stats_text, "%s\n", furi_string_get_cstr(emulation_stats->last_activity));
        }

        if(furi_string_size(emulation_stats->status_message) > 0) {
            furi_string_cat_printf(
                stats_text, "%s\n", furi_string_get_cstr(emulation_stats->status_message));
        }

        furi_string_cat_str(stats_text, "Back=Stop");

        popup_set_text(app->popup, furi_string_get_cstr(stats_text), 2, 12, AlignLeft, AlignTop);
        popup_set_icon(app->popup, 68, 20, &I_NFC_dolphin_emulation_51x64);

        furi_string_free(stats_text);
    }
}

/**
 * @brief Initialize emulation statistics tracking
 * 
 * Allocates and initializes the statistics structure and starts
 * the periodic update timer.
 * 
 * @param app Pointer to MiBandNfcApp instance
 */
static void emulation_stats_init(MiBandNfcApp* app) {
    if(emulation_stats) {
        return; // Already initialized
    }

    emulation_stats = malloc(sizeof(EmulationStats));
    emulation_stats->auth_attempts = 0;
    emulation_stats->successful_auths = 0;
    emulation_stats->failed_auths = 0;
    emulation_stats->reader_connections = 0;
    emulation_stats->data_reads = 0;
    emulation_stats->last_activity = furi_string_alloc();
    emulation_stats->status_message = furi_string_alloc();
    emulation_stats->is_active = true;

    // Create timer for UI updates every second
    emulation_stats->update_timer =
        furi_timer_alloc(emulation_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(emulation_stats->update_timer, 1000);

    furi_string_set_str(emulation_stats->status_message, "Template ready");
    furi_string_set_str(emulation_stats->last_activity, "Emulation started");
}

/**
 * @brief Free emulation statistics and stop timer
 */
static void emulation_stats_free(void) {
    if(!emulation_stats) {
        return;
    }

    emulation_stats->is_active = false;

    if(emulation_stats->update_timer) {
        furi_timer_stop(emulation_stats->update_timer);
        furi_timer_free(emulation_stats->update_timer);
    }

    furi_string_free(emulation_stats->last_activity);
    furi_string_free(emulation_stats->status_message);
    free(emulation_stats);
    emulation_stats = NULL;
}

/**
 * @brief Prepare blank magic card template from loaded dump
 * 
 * This function creates a magic card template by:
 * 1. Preserving the original UID from Block 0
 * 2. Zeroing all data blocks
 * 3. Setting all keys to 0xFF (magic keys)
 * 4. Configuring magic access bits in sector trailers
 * 
 * @param app Pointer to MiBandNfcApp instance
 */
static void miband_nfc_magic_emulator_prepare_blank_template(MiBandNfcApp* app) {
    if(!app->is_valid_nfc_data) {
        return;
    }

    if(emulation_stats) {
        furi_string_set_str(emulation_stats->status_message, "Preparing template...");
        furi_string_set_str(emulation_stats->last_activity, "Template generation");
    }

    // Save original Block 0 for UID preservation
    uint8_t original_block0_data[16];
    memcpy(original_block0_data, app->mf_classic_data->block[0].data, 16);

    // Extract UID (first 4 bytes)
    uint8_t uid[4];
    memcpy(uid, app->mf_classic_data->block[0].data, 4);

    // Calculate BCC (XOR of all UID bytes)
    uint8_t bcc = uid[0] ^ uid[1] ^ uid[2] ^ uid[3];

    // Get card structure information
    size_t total_sectors = mf_classic_get_total_sectors_num(app->mf_classic_data->type);
    size_t total_blocks = mf_classic_get_total_block_num(app->mf_classic_data->type);

    // Zero all blocks completely
    for(size_t block_idx = 0; block_idx < total_blocks; block_idx++) {
        memset(app->mf_classic_data->block[block_idx].data, 0x00, 16);
    }

    // Reconstruct Block 0 with proper Mifare Classic structure
    memcpy(app->mf_classic_data->block[0].data, uid, 4); // UID
    app->mf_classic_data->block[0].data[4] = bcc; // BCC
    app->mf_classic_data->block[0].data[5] = 0x08; // SAK for Classic 1K
    app->mf_classic_data->block[0].data[6] = 0x04; // ATQA byte 1
    app->mf_classic_data->block[0].data[7] = 0x00; // ATQA byte 2
    // Preserve bytes 8-15 from original (manufacturer data)
    memcpy(&app->mf_classic_data->block[0].data[8], &original_block0_data[8], 8);

    // Configure all sector trailers with magic card format
    for(size_t sector_idx = 0; sector_idx < total_sectors; sector_idx++) {
        // Calculate sector trailer block index
        uint8_t sector_trailer_block_idx;
        if(sector_idx < 32) {
            // First 32 sectors: 4 blocks each
            sector_trailer_block_idx = sector_idx * 4 + 3;
        } else {
            // Remaining sectors: 16 blocks each
            sector_trailer_block_idx = 32 * 4 + (sector_idx - 32) * 16 + 15;
        }

        MfClassicBlock* sector_trailer = &app->mf_classic_data->block[sector_trailer_block_idx];

        // Set magic card sector trailer format:
        memset(&sector_trailer->data[0], 0xFF, 6); // Key A: FF FF FF FF FF FF
        sector_trailer->data[6] = 0xFF; // Access bits byte 0
        sector_trailer->data[7] = 0x07; // Access bits byte 1
        sector_trailer->data[8] = 0x80; // Access bits byte 2
        sector_trailer->data[9] = 0x69; // User byte
        memset(&sector_trailer->data[10], 0xFF, 6); // Key B: FF FF FF FF FF FF

        // Enable key masks to indicate keys are available
        FURI_BIT_SET(app->mf_classic_data->key_a_mask, sector_idx);
        FURI_BIT_SET(app->mf_classic_data->key_b_mask, sector_idx);
    }

    if(emulation_stats) {
        furi_string_printf(
            emulation_stats->status_message,
            "UID %02X%02X%02X%02X",
            uid[0],
            uid[1],
            uid[2],
            uid[3]);
        furi_string_set_str(emulation_stats->last_activity, "Template ready");
    }

    FURI_LOG_I(
        TAG,
        "Prepared blank Mi Band template - UID: %02X%02X%02X%02X",
        uid[0],
        uid[1],
        uid[2],
        uid[3]);
}

/**
 * @brief NFC listener callback for emulation events
 * 
 * Handles authentication events during emulation and updates statistics.
 * Provides feedback after multiple authentications to show progress.
 * 
 * @param event NFC generic event
 * @param context Pointer to MiBandNfcApp instance
 * @return NfcCommand to continue or stop emulation
 */
static NfcCommand miband_nfc_magic_emulator_callback(NfcGenericEvent event, void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(event.protocol == NfcProtocolMfClassic) {
        const MfClassicListenerEvent* mfc_event = event.event_data;

        if(mfc_event->type == MfClassicListenerEventTypeAuthContextPartCollected) {
            // Partial authentication data collected
            if(emulation_stats) {
                furi_string_set_str(emulation_stats->last_activity, "Auth data collected");
            }
            FURI_LOG_D(TAG, "Blank template: Auth part collected");

        } else if(mfc_event->type == MfClassicListenerEventTypeAuthContextFullCollected) {
            // Full authentication completed successfully
            if(emulation_stats) {
                emulation_stats->auth_attempts++;
                emulation_stats->successful_auths++;
                furi_string_printf(
                    emulation_stats->last_activity,
                    "Auth #%lu complete",
                    emulation_stats->auth_attempts);
                furi_string_set_str(emulation_stats->status_message, "Authentication successful");
            }

            FURI_LOG_D(
                TAG,
                "Blank template: Auth complete #%lu",
                emulation_stats ? emulation_stats->auth_attempts : 0);

            // Provide feedback every 5 authentications
            if(emulation_stats && emulation_stats->auth_attempts % 5 == 0) {
                view_dispatcher_send_custom_event(
                    app->view_dispatcher, MiBandNfcCustomEventCardDetected);
            }

            // Safety limit: Stop if too many authentications (indicates potential issue)
            if(emulation_stats && emulation_stats->auth_attempts > 100) {
                furi_string_set_str(
                    emulation_stats->status_message, "Too many auth attempts - stopping");
                furi_string_set_str(emulation_stats->last_activity, "Safety stop triggered");
                FURI_LOG_W(
                    TAG, "Too many auth attempts (%lu), stopping", emulation_stats->auth_attempts);
                return NfcCommandStop;
            }
        }
    }

    return NfcCommandContinue;
}

/**
 * @brief Scene entry point
 * 
 * Initializes emulation, prepares the magic card template, and starts
 * the NFC listener to emulate the card.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_magic_emulator_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(!app->is_valid_nfc_data) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    // Initialize statistics tracking
    emulation_stats_init(app);

    // Prepare the blank magic template
    miband_nfc_magic_emulator_prepare_blank_template(app);

    // Switch to emulator view
    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdMagicEmulator);

    // Start NFC listener for emulation
    app->listener = nfc_listener_alloc(app->nfc, NfcProtocolMfClassic, app->mf_classic_data);
    nfc_listener_start(app->listener, miband_nfc_magic_emulator_callback, app);

    // Start visual notification (cyan blinking LED)
    notification_message(app->notifications, &sequence_blink_start_cyan);

    // Initial UI update
    emulation_timer_callback(app);

    FURI_LOG_I(TAG, "Started blank template emulation for Mi Band");
}

/**
 * @brief Scene event handler
 * 
 * Handles card detection events and back button press to stop emulation.
 * 
 * @param context Pointer to MiBandNfcApp instance
 * @param event Scene manager event
 * @return true if event was consumed, false otherwise
 */
bool miband_nfc_scene_magic_emulator_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeCustom) {
        switch(event.event) {
        case MiBandNfcCustomEventCardDetected:
            // Periodic feedback during active reading
            if(emulation_stats) {
                furi_string_set_str(emulation_stats->status_message, "Mi Band actively reading");
                // Provide tactile feedback
                notification_message(app->notifications, &sequence_single_vibro);
            }
            consumed = true;
            break;
        default:
            break;
        }
    } else if(event.type == SceneManagerEventTypeBack) {
        // User pressed back - stop emulation
        if(app->listener) {
            nfc_listener_stop(app->listener);
            nfc_listener_free(app->listener);
            app->listener = NULL;
        }

        emulation_stats_free();
        scene_manager_previous_scene(app->scene_manager);
        consumed = true;
    }

    return consumed;
}

/**
 * @brief Scene exit handler
 * 
 * Stops emulation, cleans up resources, and stops LED notifications.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_magic_emulator_on_exit(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(app->listener) {
        nfc_listener_stop(app->listener);
        nfc_listener_free(app->listener);
        app->listener = NULL;
    }

    emulation_stats_free();
    notification_message(app->notifications, &sequence_blink_stop);
    popup_reset(app->popup);

    FURI_LOG_I(TAG, "Stopped blank template emulation");
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_magic_saver.c ----
/**
 * @file miband_nfc_scene_magic_saver.c
 * @brief Magic dump converter with GUI updates
 */

#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

static bool miband_nfc_save_magic_dump(MiBandNfcApp* app) {
    if(!app->is_valid_nfc_data) {
        FURI_LOG_E(TAG, "No valid NFC data to save");
        return false;
    }

    FURI_LOG_D(TAG, "Preparing magic dump with 0xFF keys");

    MfClassicData* magic_data = mf_classic_alloc();
    if(!magic_data) {
        FURI_LOG_E(TAG, "Failed to allocate MfClassic data");
        return false;
    }

    mf_classic_copy(magic_data, app->mf_classic_data);
    size_t total_sectors = mf_classic_get_total_sectors_num(magic_data->type);

    for(size_t sector_idx = 0; sector_idx < total_sectors; sector_idx++) {
        FuriString* progress = furi_string_alloc();
        furi_string_printf(
            progress, "Converting keys\nSector %zu/%zu\n\n", sector_idx + 1, total_sectors);

        uint32_t percent = ((sector_idx + 1) * 100) / total_sectors;
        furi_string_cat_str(progress, "[");
        for(uint8_t i = 0; i < 20; i++) {
            if(i < (percent / 5)) {
                furi_string_cat_str(progress, "=");
            } else {
                furi_string_cat_str(progress, " ");
            }
        }
        furi_string_cat_printf(progress, "]\n%lu%%", percent);

        popup_set_text(app->popup, furi_string_get_cstr(progress), 64, 22, AlignCenter, AlignTop);
        furi_string_free(progress);
        furi_delay_ms(20);

        uint8_t sector_trailer_block_idx;
        if(sector_idx < 32) {
            sector_trailer_block_idx = sector_idx * 4 + 3;
        } else {
            sector_trailer_block_idx = 32 * 4 + (sector_idx - 32) * 16 + 15;
        }

        MfClassicBlock* sector_trailer = &magic_data->block[sector_trailer_block_idx];

        memset(&sector_trailer->data[0], 0xFF, 6);
        sector_trailer->data[6] = 0xFF;
        sector_trailer->data[7] = 0x07;
        sector_trailer->data[8] = 0x80;
        sector_trailer->data[9] = 0x69;
        memset(&sector_trailer->data[10], 0xFF, 6);

        FURI_BIT_SET(magic_data->key_a_mask, sector_idx);
        FURI_BIT_SET(magic_data->key_b_mask, sector_idx);
    }

    popup_set_text(app->popup, "Saving file...", 64, 30, AlignCenter, AlignTop);
    furi_delay_ms(100);

    FuriString* output_path = furi_string_alloc();
    furi_string_set(output_path, app->file_path);

    size_t ext_pos = furi_string_search_rchar(output_path, '.');
    if(ext_pos != FURI_STRING_FAILURE) {
        furi_string_left(output_path, ext_pos);
    }
    furi_string_cat_str(output_path, "_magic.nfc");

    nfc_device_set_data(app->nfc_device, NfcProtocolMfClassic, magic_data);
    bool save_success = nfc_device_save(app->nfc_device, furi_string_get_cstr(output_path));
    nfc_device_set_data(app->nfc_device, NfcProtocolMfClassic, app->mf_classic_data);

    FURI_LOG_I(
        TAG,
        "Magic dump save %s: %s",
        save_success ? "success" : "failed",
        furi_string_get_cstr(output_path));

    mf_classic_free(magic_data);
    furi_string_free(output_path);

    return save_success;
}

void miband_nfc_scene_magic_saver_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(!app->is_valid_nfc_data) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    popup_reset(app->popup);
    popup_set_header(app->popup, "Saving Magic Dump", 64, 4, AlignCenter, AlignTop);
    popup_set_text(app->popup, "Preparing...", 64, 22, AlignCenter, AlignTop);

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdMagicEmulator);
    notification_message(app->notifications, &sequence_blink_start_magenta);

    bool save_success = miband_nfc_save_magic_dump(app);

    popup_reset(app->popup);

    if(save_success) {
        notification_message(app->notifications, &sequence_success);
        popup_set_header(app->popup, "Success!", 64, 4, AlignCenter, AlignTop);
        popup_set_text(
            app->popup, "Magic dump saved\nwith _magic suffix", 64, 22, AlignCenter, AlignTop);
        popup_set_icon(app->popup, 32, 28, &I_DolphinSuccess_91x55);
        furi_delay_ms(2000);
    } else {
        notification_message(app->notifications, &sequence_error);
        popup_set_header(app->popup, "Failed", 64, 4, AlignCenter, AlignTop);
        popup_set_text(app->popup, "Could not save file", 64, 22, AlignCenter, AlignTop);
        popup_set_icon(app->popup, 40, 28, &I_WarningDolphinFlip_45x42);
        furi_delay_ms(2000);
    }

    scene_manager_search_and_switch_to_another_scene(app->scene_manager, MiBandNfcSceneMainMenu);
}

bool miband_nfc_scene_magic_saver_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeBack) {
        scene_manager_search_and_switch_to_another_scene(
            app->scene_manager, MiBandNfcSceneMainMenu);
        consumed = true;
    }

    return consumed;
}

void miband_nfc_scene_magic_saver_on_exit(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    notification_message(app->notifications, &sequence_blink_stop);
    popup_reset(app->popup);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_main_menu.c ----
/**
 * @file miband_nfc_scene_main_menu.c
 * @brief Main menu scene - Updated with new features
 */

#include "miband_nfc_i.h"

void miband_nfc_app_submenu_callback(void* context, uint32_t index) {
    MiBandNfcApp* app = context;
    view_dispatcher_send_custom_event(app->view_dispatcher, index);
}

void miband_nfc_scene_main_menu_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    submenu_reset(app->submenu);
    submenu_set_header(app->submenu, "Mi Band NFC");

    // Quick operations
    submenu_add_item(
        app->submenu,
        "Quick UID Check",
        SubmenuIndexQuickUidCheck,
        miband_nfc_app_submenu_callback,
        app);

    // Emulation functions
    submenu_add_item(
        app->submenu,
        "Emulate Magic Card",
        SubmenuIndexEmulateNfcMagic,
        miband_nfc_app_submenu_callback,
        app);

    // Writing functions (now with auto-backup)
    submenu_add_item(
        app->submenu,
        "Write Original Data",
        SubmenuIndexWriteOriginalData,
        miband_nfc_app_submenu_callback,
        app);

    // Save magic dump
    submenu_add_item(
        app->submenu,
        "Save Magic Dump",
        SubmenuIndexSaveMagic,
        miband_nfc_app_submenu_callback,
        app);

    // Verification
    submenu_add_item(
        app->submenu, "Verify Write", SubmenuIndexVerify, miband_nfc_app_submenu_callback, app);

    // Settings
    submenu_add_item(
        app->submenu, "Settings >", SubmenuIndexSettings, miband_nfc_app_submenu_callback, app);

    // About
    submenu_add_item(
        app->submenu, "About", SubmenuIndexAbout, miband_nfc_app_submenu_callback, app);

    submenu_set_selected_item(app->submenu, app->last_selected_submenu_index);
    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdMainMenu);
}

bool miband_nfc_scene_main_menu_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeCustom) {
        app->last_selected_submenu_index = event.event;

        switch(event.event) {
        case SubmenuIndexQuickUidCheck:
            // NEW: Quick UID check
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneUidCheck);
            consumed = true;
            break;

        case SubmenuIndexEmulateNfcMagic:
            app->current_operation = OperationTypeEmulateMagic;
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneFileSelect);
            consumed = true;
            break;

        case SubmenuIndexWriteOriginalData:
            // NEW: Route through backup scene first
            app->current_operation = OperationTypeWriteOriginal;
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneFileSelect);
            consumed = true;
            break;

        case SubmenuIndexSaveMagic:
            app->current_operation = OperationTypeSaveMagic;
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneFileSelect);
            consumed = true;
            break;

        case SubmenuIndexVerify:
            app->current_operation = OperationTypeVerify;
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneFileSelect);
            consumed = true;
            break;

        case SubmenuIndexSettings:
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneSettings);
            consumed = true;
            break;

        case SubmenuIndexAbout:
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneAbout);
            consumed = true;
            break;
        }
    }

    return consumed;
}

void miband_nfc_scene_main_menu_on_exit(void* context) {
    UNUSED(context);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_scanner.c ----
#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

void miband_nfc_scene_scanner_scan_callback(NfcScannerEvent event, void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;
    if(event.type == NfcScannerEventTypeDetected) {
        view_dispatcher_send_custom_event(app->view_dispatcher, MiBandNfcCustomEventCardDetected);

        if(*event.data.protocols == NfcProtocolMfClassic) {
            view_dispatcher_send_custom_event(
                app->view_dispatcher, MiBandNfcCustomEventMfClassicCard);
        } else {
            view_dispatcher_send_custom_event(app->view_dispatcher, MiBandNfcCustomEventWrongCard);
        }
    }
}

void miband_nfc_scene_scanner_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    popup_reset(app->popup);
    popup_set_header(app->popup, "Scanning for Mi Band", 64, 4, AlignCenter, AlignTop);
    popup_set_text(
        app->popup,
        "Place Mi Band near\nthe Flipper Zero\n\nSearching...",
        64,
        22,
        AlignCenter,
        AlignTop);

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);

    app->poller = NULL;
    app->scanner = nfc_scanner_alloc(app->nfc);
    nfc_scanner_start(app->scanner, miband_nfc_scene_scanner_scan_callback, app);
    app->is_scan_active = true;

    notification_message(app->notifications, &sequence_blink_start_cyan);
    FURI_LOG_I(TAG, "Enter scanner scene");
}

bool miband_nfc_scene_scanner_on_event(void* context, SceneManagerEvent event) {
    furi_assert(context);
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeCustom) {
        switch(event.event) {
        case MiBandNfcCustomEventCardDetected:
            popup_reset(app->popup);
            popup_set_header(app->popup, "Mi Band Found!", 64, 4, AlignCenter, AlignTop);
            popup_set_text(
                app->popup,
                "Hold steady...\nDon't move the card\n\nAnalyzing...",
                64,
                22,
                AlignCenter,
                AlignTop);
            consumed = true;
            break;

        case MiBandNfcCustomEventCardLost:
            popup_reset(app->popup);
            popup_set_header(app->popup, "Card Lost", 64, 4, AlignCenter, AlignTop);
            popup_set_text(
                app->popup,
                "Mi Band moved away\nPlace it back near\nthe Flipper",
                64,
                22,
                AlignCenter,
                AlignTop);
            consumed = true;
            break;

        case MiBandNfcCustomEventWrongCard:
            if(app->scanner) {
                nfc_scanner_stop(app->scanner);
                nfc_scanner_free(app->scanner);
                app->scanner = NULL;
            }
            app->is_scan_active = false;

            popup_reset(app->popup);
            popup_set_header(app->popup, "Wrong Card Type", 64, 4, AlignCenter, AlignTop);
            popup_set_text(
                app->popup,
                "This is not a\nMifare Classic card\n\nTry again",
                64,
                22,
                AlignCenter,
                AlignTop);
            popup_set_icon(app->popup, 40, 32, &I_WarningDolphinFlip_45x42);

            notification_message(app->notifications, &sequence_error);
            furi_delay_ms(2000);
            scene_manager_set_scene_state(app->scene_manager, MiBandNfcSceneScanner, 0);
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneScanner);
            consumed = true;
            break;

        case MiBandNfcCustomEventMfClassicCard:
            if(app->scanner) {
                nfc_scanner_stop(app->scanner);
                nfc_scanner_free(app->scanner);
                app->scanner = NULL;
            }
            app->is_scan_active = false;
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneWriter);
            consumed = true;
            break;
        default:
            break;
        }
    } else if(event.type == SceneManagerEventTypeBack) {
        scene_manager_search_and_switch_to_another_scene(
            app->scene_manager, MiBandNfcSceneMainMenu);
        consumed = true;
    }
    return consumed;
}

void miband_nfc_scene_scanner_on_exit(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;
    if(app->scanner) {
        nfc_scanner_stop(app->scanner);
        nfc_scanner_free(app->scanner);
        app->scanner = NULL;
    }
    app->is_scan_active = false;
    app->poller = NULL;

    notification_message(app->notifications, &sequence_blink_stop);
    popup_reset(app->popup);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_settings.c ----
/**
 * @file miband_nfc_scene_settings.c
 * @brief Settings menu with persistent storage
 */

#include "miband_nfc_i.h"

#define TAG            "MiBandNfc"
#define SETTINGS_PATH  EXT_PATH("apps_data/miband_nfc/settings.bin")
#define SETTINGS_MAGIC 0x4D424E43 // "MBNC"

typedef struct {
    uint32_t magic;
    bool auto_backup_enabled;
    bool verify_after_write;
    bool show_detailed_progress;
    bool enable_logging;
} MiBandSettings;

bool miband_settings_save(MiBandNfcApp* app) {
    if(!app || !app->storage) {
        FURI_LOG_E(TAG, "Invalid app or storage");
        return false;
    }

    Storage* storage = app->storage;

    storage_simply_mkdir(storage, EXT_PATH("apps_data"));
    storage_simply_mkdir(storage, EXT_PATH("apps_data/miband_nfc"));

    MiBandSettings settings = {
        .magic = SETTINGS_MAGIC,
        .auto_backup_enabled = app->auto_backup_enabled,
        .verify_after_write = app->verify_after_write,
        .show_detailed_progress = app->show_detailed_progress,
        .enable_logging = app->enable_logging,
    };

    File* file = storage_file_alloc(storage);
    if(!file) {
        FURI_LOG_E(TAG, "Failed to alloc file for save");
        return false;
    }

    bool success = false;

    if(storage_file_open(file, SETTINGS_PATH, FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
        success = storage_file_write(file, &settings, sizeof(MiBandSettings)) ==
                  sizeof(MiBandSettings);
        storage_file_close(file);
        FURI_LOG_I(TAG, "Settings saved: %s", success ? "OK" : "FAIL");
    } else {
        FURI_LOG_E(TAG, "Failed to open settings file for writing");
    }

    storage_file_free(file);
    return success;
}

bool miband_settings_load(MiBandNfcApp* app) {
    if(!app || !app->storage) {
        FURI_LOG_E(TAG, "Invalid app or storage");
        return false;
    }
    Storage* storage = app->storage;
    MiBandSettings settings;
    bool success = false;

    File* file = storage_file_alloc(storage);
    if(!file) {
        FURI_LOG_E(TAG, "Failed to alloc file");
        return false;
    }
    if(storage_file_open(file, SETTINGS_PATH, FSAM_READ, FSOM_OPEN_EXISTING)) {
        if(storage_file_read(file, &settings, sizeof(MiBandSettings)) == sizeof(MiBandSettings)) {
            if(settings.magic == SETTINGS_MAGIC) {
                app->auto_backup_enabled = settings.auto_backup_enabled;
                app->verify_after_write = settings.verify_after_write;
                app->show_detailed_progress = settings.show_detailed_progress;
                app->enable_logging = settings.enable_logging;
                success = true;
                FURI_LOG_I(TAG, "Settings loaded successfully");
            } else {
                FURI_LOG_W(TAG, "Invalid settings magic");
            }
        }
        storage_file_close(file);
    } else {
        FURI_LOG_I(TAG, "No settings file found, using defaults");
    }

    storage_file_free(file);
    return success;
}

void settings_submenu_callback(void* context, uint32_t index) {
    MiBandNfcApp* app = context;
    view_dispatcher_send_custom_event(app->view_dispatcher, index);
}

void miband_nfc_scene_settings_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    submenu_reset(app->submenu);
    submenu_set_header(app->submenu, "Settings");

    // Auto Backup toggle
    FuriString* backup_text =
        furi_string_alloc_printf("Auto Backup: %s", app->auto_backup_enabled ? "ON" : "OFF");
    submenu_add_item(
        app->submenu,
        furi_string_get_cstr(backup_text),
        SettingsIndexAutoBackup,
        settings_submenu_callback,
        app);
    furi_string_free(backup_text);

    // Verify after write toggle
    FuriString* verify_text =
        furi_string_alloc_printf("Verify After Write: %s", app->verify_after_write ? "ON" : "OFF");
    submenu_add_item(
        app->submenu,
        furi_string_get_cstr(verify_text),
        SettingsIndexVerifyAfterWrite,
        settings_submenu_callback,
        app);
    furi_string_free(verify_text);

    // Show detailed progress toggle
    FuriString* progress_text = furi_string_alloc_printf(
        "Detailed Progress: %s", app->show_detailed_progress ? "ON" : "OFF");
    submenu_add_item(
        app->submenu,
        furi_string_get_cstr(progress_text),
        SettingsIndexShowProgress,
        settings_submenu_callback,
        app);
    furi_string_free(progress_text);

    // Enable logging toggle
    FuriString* logging_text =
        furi_string_alloc_printf("Enable Logging: %s", app->enable_logging ? "ON" : "OFF");
    submenu_add_item(
        app->submenu,
        furi_string_get_cstr(logging_text),
        SettingsIndexEnableLogging,
        settings_submenu_callback,
        app);
    furi_string_free(logging_text);

    // Export logs
    size_t log_count = miband_logger_get_count(app->logger);
    FuriString* export_text = furi_string_alloc_printf("Export Logs (%zu entries)", log_count);
    submenu_add_item(
        app->submenu,
        furi_string_get_cstr(export_text),
        SettingsIndexExportLogs,
        settings_submenu_callback,
        app);
    furi_string_free(export_text);

    // Clear logs
    submenu_add_item(
        app->submenu, "Clear Logs", SettingsIndexClearLogs, settings_submenu_callback, app);

    // Back button
    submenu_add_item(
        app->submenu, "< Back to Menu", SettingsIndexBack, settings_submenu_callback, app);

    submenu_set_selected_item(app->submenu, 0);
    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdMainMenu);
}

bool miband_nfc_scene_settings_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeCustom) {
        switch(event.event) {
        case SettingsIndexAutoBackup:
            app->auto_backup_enabled = !app->auto_backup_enabled;
            miband_settings_save(app);

            // Refresh scene
            miband_nfc_scene_settings_on_exit(app);
            miband_nfc_scene_settings_on_enter(app);
            consumed = true;
            break;

        case SettingsIndexVerifyAfterWrite:
            app->verify_after_write = !app->verify_after_write;
            miband_settings_save(app);

            // Refresh scene
            miband_nfc_scene_settings_on_exit(app);
            miband_nfc_scene_settings_on_enter(app);
            consumed = true;
            break;

        case SettingsIndexShowProgress:
            app->show_detailed_progress = !app->show_detailed_progress;
            miband_settings_save(app);

            // Refresh scene
            miband_nfc_scene_settings_on_exit(app);
            miband_nfc_scene_settings_on_enter(app);
            consumed = true;
            break;

        case SettingsIndexEnableLogging:
            app->enable_logging = !app->enable_logging;
            miband_settings_save(app);
            miband_logger_set_enabled(app->logger, app->enable_logging);
            miband_nfc_scene_settings_on_exit(app);
            miband_nfc_scene_settings_on_enter(app);
            consumed = true;
            break;

        case SettingsIndexExportLogs: {
            DateTime dt;
            furi_hal_rtc_get_datetime(&dt);
            FuriString* filename = furi_string_alloc_printf(
                "log_%04d%02d%02d_%02d%02d%02d.txt",
                dt.year,
                dt.month,
                dt.day,
                dt.hour,
                dt.minute,
                dt.second);

            bool success = miband_logger_export(app->logger, furi_string_get_cstr(filename));

            popup_reset(app->popup);
            popup_set_header(
                app->popup, success ? "Success" : "Failed", 64, 4, AlignCenter, AlignTop);
            popup_set_text(
                app->popup,
                success ? "Logs exported" : "Export failed",
                64,
                30,
                AlignCenter,
                AlignTop);
            view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);
            furi_delay_ms(2000);

            miband_nfc_scene_settings_on_exit(app);
            miband_nfc_scene_settings_on_enter(app);
            furi_string_free(filename);
            consumed = true;
            break;
        }

        case SettingsIndexClearLogs:
            miband_logger_clear(app->logger);
            miband_nfc_scene_settings_on_exit(app);
            miband_nfc_scene_settings_on_enter(app);
            consumed = true;
            break;

        case SettingsIndexBack:
            scene_manager_previous_scene(app->scene_manager);
            consumed = true;
            break;
        }
    } else if(event.type == SceneManagerEventTypeBack) {
        scene_manager_previous_scene(app->scene_manager);
        consumed = true;
    }

    return consumed;
}

void miband_nfc_scene_settings_on_exit(void* context) {
    MiBandNfcApp* app = context;
    submenu_reset(app->submenu);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_uid_check.c ----
/**
 * @file miband_nfc_scene_uid_check.c
 * @brief Quick UID checker - FIXED
 */

#include "miband_nfc_i.h"

#define TAG                "MiBandNfc"
#define MAX_FILES_TO_CHECK 20
#define MAX_SCAN_TIME_MS   5000

typedef struct {
    char filename[128];
    char path[256];
} FoundFile;

static void scan_directory_for_uid(
    Storage* storage,
    const char* directory,
    const uint8_t* target_uid,
    FoundFile* found_files,
    size_t max_files,
    size_t* found_count,
    Popup* popup) {
    File* dir = storage_file_alloc(storage);
    if(!dir) return;

    if(!storage_dir_open(dir, directory)) {
        storage_file_free(dir);
        return;
    }

    FileInfo file_info;
    char name[128];
    FuriString* full_path = furi_string_alloc();
    uint32_t files_checked = 0;
    uint32_t start_time = furi_get_tick();

    while(storage_dir_read(dir, &file_info, name, sizeof(name))) {
        if(furi_get_tick() - start_time > MAX_SCAN_TIME_MS) break;
        if(files_checked % 10 == 0) furi_delay_ms(10);
        if(name[0] == '.') continue;
        if(file_info.flags & FSF_DIRECTORY) continue;
        if(!strstr(name, ".nfc")) continue;

        files_checked++;
        if(files_checked > MAX_FILES_TO_CHECK) break;

        if(files_checked % 5 == 0 && popup) {
            FuriString* msg = furi_string_alloc_printf("Scanning...\n%lu files", files_checked);
            popup_set_text(popup, furi_string_get_cstr(msg), 64, 30, AlignCenter, AlignTop);
            furi_string_free(msg);
        }

        furi_string_printf(full_path, "%s/%s", directory, name);
        NfcDevice* temp_device = nfc_device_alloc();
        if(!temp_device) continue;

        if(nfc_device_load(temp_device, furi_string_get_cstr(full_path))) {
            if(nfc_device_get_protocol(temp_device) == NfcProtocolMfClassic) {
                const MfClassicData* data = nfc_device_get_data(temp_device, NfcProtocolMfClassic);
                if(data && memcmp(data->block[0].data, target_uid, 4) == 0) {
                    if(*found_count >= max_files) {
                        FURI_LOG_W(TAG, "Max files reached");
                        break; // Esci dal loop
                    }
                    strncpy(found_files[*found_count].filename, name, 127);
                    found_files[*found_count].filename[127] = '\0';
                    strncpy(found_files[*found_count].path, furi_string_get_cstr(full_path), 255);
                    found_files[*found_count].path[255] = '\0';
                    (*found_count)++;
                }
            }
        }
        nfc_device_free(temp_device);
        furi_delay_ms(5);
    }

    furi_string_free(full_path);
    storage_dir_close(dir);
    storage_file_free(dir);
}

static FuriString* generate_uid_report(
    const MfClassicBlock* block0,
    const FoundFile* found_files,
    size_t found_count) {
    FuriString* report = furi_string_alloc();
    if(!report) return NULL;

    furi_string_printf(
        report,
        "Card Info\n"
        "=========\n\n"
        "UID: %02X %02X %02X %02X\n"
        "BCC: %02X %s\n"
        "SAK: %02X\n"
        "ATQA: %02X %02X\n\n",
        block0->data[0],
        block0->data[1],
        block0->data[2],
        block0->data[3],
        block0->data[4],
        (block0->data[4] ==
         (block0->data[0] ^ block0->data[1] ^ block0->data[2] ^ block0->data[3])) ?
            "(OK)" :
            "(BAD)",
        block0->data[5],
        block0->data[6],
        block0->data[7]);

    furi_string_cat_str(report, "Manufacturer:\n  ");
    for(int i = 8; i < 16; i++) {
        furi_string_cat_printf(report, "%02X ", block0->data[i]);
        if(i == 11) furi_string_cat_str(report, "\n  ");
    }

    furi_string_cat_str(report, "\n\nMatching Files:\n===============\n");

    if(found_count == 0) {
        furi_string_cat_str(report, "No matches found\n");
    } else {
        furi_string_cat_printf(report, "%zu file(s):\n\n", found_count);
        for(size_t i = 0; i < found_count; i++) {
            const char* rel_path = strstr(found_files[i].path, "/nfc/");
            furi_string_cat_printf(
                report, "%zu. %s\n", i + 1, rel_path ? rel_path + 5 : found_files[i].filename);
        }
    }

    furi_string_cat_str(report, "\nPress Back");
    return report;
}

void miband_nfc_scene_uid_check_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    // Reset buffer
    furi_string_reset(app->temp_text_buffer);

    text_box_reset(app->text_box_report);
    dialog_ex_reset(app->dialog_ex);
    popup_reset(app->popup);

    popup_set_header(app->popup, "UID Check", 64, 4, AlignCenter, AlignTop);
    popup_set_text(app->popup, "Place card near\nFlipper Zero", 64, 22, AlignCenter, AlignTop);
    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);
    notification_message(app->notifications, &sequence_blink_start_cyan);

    Iso14443_3aData iso_data = {0};
    bool read_success = false;

    for(int attempt = 0; attempt < 15 && !read_success; attempt++) {
        if(attempt % 3 == 0) {
            FuriString* msg = furi_string_alloc_printf("Reading UID...\n%d/15", attempt + 1);
            popup_set_text(app->popup, furi_string_get_cstr(msg), 64, 22, AlignCenter, AlignTop);
            furi_string_free(msg);
        }

        furi_delay_ms(300);

        Iso14443_3aError error = iso14443_3a_poller_sync_read(app->nfc, &iso_data);

        if(error == Iso14443_3aErrorNone && iso_data.uid_len >= 4) {
            read_success = true;
            break;
        }
    }

    notification_message(app->notifications, &sequence_blink_stop);

    if(!read_success) {
        notification_message(app->notifications, &sequence_error);
        popup_set_text(app->popup, "Card not found", 64, 22, AlignCenter, AlignTop);
        furi_delay_ms(1500);
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    notification_message(app->notifications, &sequence_success);
    popup_set_text(app->popup, "UID read!\nScanning...", 64, 22, AlignCenter, AlignTop);
    furi_delay_ms(200);

    FoundFile* found_files = malloc(sizeof(FoundFile) * MAX_FILES_TO_CHECK);
    if(!found_files) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    size_t found_count = 0;
    scan_directory_for_uid(
        app->storage,
        NFC_APP_FOLDER,
        iso_data.uid,
        found_files,
        MAX_FILES_TO_CHECK,
        &found_count,
        app->popup);

    MfClassicBlock block0 = {0};
    memcpy(block0.data, iso_data.uid, 4);
    block0.data[4] = iso_data.uid[0] ^ iso_data.uid[1] ^ iso_data.uid[2] ^ iso_data.uid[3];
    block0.data[5] = iso_data.sak;
    block0.data[6] = iso_data.atqa[0];
    block0.data[7] = iso_data.atqa[1];

    FuriString* report = generate_uid_report(&block0, found_files, found_count);
    free(found_files);

    if(!report) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    furi_string_set(app->temp_text_buffer, report);
    furi_string_free(report);

    popup_reset(app->popup);
    furi_delay_ms(10);

    text_box_reset(app->text_box_report);
    text_box_set_text(app->text_box_report, furi_string_get_cstr(app->temp_text_buffer));
    text_box_set_font(app->text_box_report, TextBoxFontText);
    text_box_set_focus(app->text_box_report, TextBoxFocusStart);

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdUidReport);
}

bool miband_nfc_scene_uid_check_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;

    if(event.type == SceneManagerEventTypeBack) {
        scene_manager_previous_scene(app->scene_manager);
        return true;
    }
    return false;
}

void miband_nfc_scene_uid_check_on_exit(void* context) {
    MiBandNfcApp* app = context;
    notification_message(app->notifications, &sequence_blink_stop);
    popup_reset(app->popup);
    text_box_reset(app->text_box_report);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_verify.c ----
/**
 * @file miband_nfc_scene_verify.c
 * @brief Data verification scene (FIXED VERSION)
 * 
 * This scene reads data from the Mi Band NFC and compares it with the original
 * dump file to verify that the write operation was successful.
 * 
 * Key improvements in this version:
 * - Tries dump keys first, then falls back to 0xFF magic keys
 * - Smart comparison that ignores keys in sector trailers
 * - Compares only UID/BCC in Block 0 (not manufacturer data)
 * - Robust authentication with retry logic
 * - Detailed progress feedback
 */

#include "miband_nfc_i.h"

#define TAG "MiBandNfc"

enum {
    MiBandNfcSceneVerifyStateCardSearch,
    MiBandNfcSceneVerifyStateReading,
    MiBandNfcSceneVerifyStateComparison,
};

static void verify_dialog_callback(DialogExResult result, void* context) {
    MiBandNfcApp* app = context;

    if(result == DialogExResultLeft) {
        // Exit - torna al menu
        view_dispatcher_send_custom_event(app->view_dispatcher, MiBandNfcCustomEventVerifyExit);
    } else if(result == DialogExResultRight) {
        // View Details - vai al diff viewer
        view_dispatcher_send_custom_event(
            app->view_dispatcher, MiBandNfcCustomEventVerifyViewDetails);
    }
}

/**
 * @brief Verification progress tracker
 * 
 * Tracks reading progress, authentication attempts, and comparison results
 * to provide detailed feedback to the user.
 */
typedef struct {
    uint32_t current_sector;
    uint32_t total_sectors;
    uint32_t sectors_read;
    uint32_t sectors_failed;
    uint32_t auth_attempts;
    uint32_t auth_successes;
    uint32_t blocks_compared;
    uint32_t blocks_different;
    FuriString* current_operation;
    FuriString* last_result;
    FuriString* error_details;
    bool reading_complete;
} VerifyTracker;

static VerifyTracker verify_tracker = {0};

/**
 * @brief Initialize verification tracker
 */
static void verify_tracker_init(void) {
    verify_tracker.current_sector = 0;
    verify_tracker.total_sectors = 0;
    verify_tracker.sectors_read = 0;
    verify_tracker.sectors_failed = 0;
    verify_tracker.auth_attempts = 0;
    verify_tracker.auth_successes = 0;
    verify_tracker.blocks_compared = 0;
    verify_tracker.blocks_different = 0;
    verify_tracker.reading_complete = false;

    if(!verify_tracker.current_operation) {
        verify_tracker.current_operation = furi_string_alloc();
        verify_tracker.last_result = furi_string_alloc();
        verify_tracker.error_details = furi_string_alloc();
    }

    furi_string_reset(verify_tracker.current_operation);
    furi_string_reset(verify_tracker.last_result);
    furi_string_reset(verify_tracker.error_details);
}

/**
 * @brief Free verification tracker resources
 */
static void verify_tracker_free(void) {
    if(verify_tracker.current_operation) {
        furi_string_free(verify_tracker.current_operation);
        furi_string_free(verify_tracker.last_result);
        furi_string_free(verify_tracker.error_details);
        verify_tracker.current_operation = NULL;
        verify_tracker.last_result = NULL;
        verify_tracker.error_details = NULL;
    }
}

/**
 * @brief Update verification UI with current progress
 * 
 * Displays progress bar, statistics, and current operation status.
 * 
 * @param app Pointer to MiBandNfcApp instance
 * @param header Header text for the popup
 */
static void update_verify_ui(MiBandNfcApp* app, const char* header) {
    popup_set_header(app->popup, header, 64, 2, AlignCenter, AlignTop);

    FuriString* status_text = furi_string_alloc();

    if(verify_tracker.total_sectors > 0) {
        uint32_t progress_percent =
            verify_tracker.reading_complete ?
                100 :
                (verify_tracker.current_sector * 100) / verify_tracker.total_sectors;

        furi_string_printf(
            status_text,
            "Sector: %lu/%lu\n\n",
            verify_tracker.current_sector,
            verify_tracker.total_sectors);

        furi_string_cat_str(status_text, "[");
        for(uint32_t i = 0; i < 20; i++) {
            if(i < (progress_percent / 5)) {
                furi_string_cat_str(status_text, "=");
            } else if(i == (progress_percent / 5) && progress_percent < 100) {
                furi_string_cat_str(status_text, ">");
            } else {
                furi_string_cat_str(status_text, " ");
            }
        }
        furi_string_cat_printf(status_text, "]\n%lu%%\n\n", progress_percent);
    }

    if(furi_string_size(verify_tracker.current_operation) > 0) {
        furi_string_cat_printf(
            status_text, "%s\n", furi_string_get_cstr(verify_tracker.current_operation));
    }

    if(verify_tracker.auth_attempts > 0) {
        furi_string_cat_printf(
            status_text,
            "Auth: %lu/%lu\n",
            verify_tracker.auth_successes,
            verify_tracker.auth_attempts);
    }

    if(verify_tracker.blocks_compared > 0) {
        furi_string_cat_printf(status_text, "Compared: %lu\n", verify_tracker.blocks_compared);
        if(verify_tracker.blocks_different > 0) {
            furi_string_cat_printf(status_text, "Diff: %lu\n", verify_tracker.blocks_different);
        }
    }

    if(furi_string_size(verify_tracker.error_details) > 0) {
        furi_string_cat_printf(
            status_text, "\n%s", furi_string_get_cstr(verify_tracker.error_details));
    }

    popup_set_text(app->popup, furi_string_get_cstr(status_text), 4, 12, AlignLeft, AlignTop);

    // Icona solo alla fine
    if(verify_tracker.reading_complete) {
        if(furi_string_size(verify_tracker.error_details) > 0) {
            popup_set_icon(app->popup, 96, 20, &I_WarningDolphinFlip_45x42);
        } else {
            popup_set_icon(app->popup, 90, 16, &I_DolphinSuccess_91x55);
        }
    }

    furi_string_free(status_text);
}

/**
 * @brief Read a sector using multiple key strategies
 * 
 * This is the KEY FIX: tries dump keys first (Key A and Key B from the original
 * dump file), then falls back to 0xFF magic keys if those fail. This handles
 * both scenarios:
 * 1. Mi Band has original keys after successful write
 * 2. Mi Band still has magic keys from emulation
 * 
 * @param app Pointer to MiBandNfcApp instance
 * @param sector Sector number to read
 * @param first_block First block index of the sector
 * @param blocks_in_sector Number of blocks in the sector
 * @return true if sector read successfully, false otherwise
 */
static bool read_sector_with_keys(
    MiBandNfcApp* app,
    size_t sector,
    uint8_t first_block,
    uint8_t blocks_in_sector) {
    MfClassicError error;
    MfClassicAuthContext auth_context;
    MfClassicSectorTrailer* sec_tr =
        mf_classic_get_sector_trailer_by_sector(app->mf_classic_data, sector);

    if(!sec_tr) {
        FURI_LOG_E(TAG, "Sector %zu: No trailer in dump", sector);
        return false;
    }

    // Build list of keys to try
    MfClassicKey keys_to_try[3];
    MfClassicKeyType key_types[3];
    int keys_count = 0;

    // STRATEGY: Try dump keys first, then magic keys as fallback

    // 1. Try Key A from dump
    if(mf_classic_is_key_found(app->mf_classic_data, sector, MfClassicKeyTypeA)) {
        memcpy(keys_to_try[keys_count].data, sec_tr->key_a.data, 6);
        key_types[keys_count] = MfClassicKeyTypeA;
        keys_count++;
    }

    // 2. Try Key B from dump
    if(mf_classic_is_key_found(app->mf_classic_data, sector, MfClassicKeyTypeB)) {
        memcpy(keys_to_try[keys_count].data, sec_tr->key_b.data, 6);
        key_types[keys_count] = MfClassicKeyTypeB;
        keys_count++;
    }

    // 3. Try magic key 0xFF as fallback
    memset(keys_to_try[keys_count].data, 0xFF, 6);
    key_types[keys_count] = MfClassicKeyTypeA;
    keys_count++;

    // Try each key in order
    for(int key_idx = 0; key_idx < keys_count; key_idx++) {
        verify_tracker.auth_attempts++;

        error = mf_classic_poller_sync_auth(
            app->nfc, first_block, &keys_to_try[key_idx], key_types[key_idx], &auth_context);

        if(error != MfClassicErrorNone) {
            continue; // Try next key
        }

        verify_tracker.auth_successes++;
        FURI_LOG_D(TAG, "Sector %zu: Auth OK with key %d", sector, key_idx);

        // Read all blocks in the sector
        bool all_blocks_read = true;
        for(uint8_t block_in_sector = 0; block_in_sector < blocks_in_sector; block_in_sector++) {
            size_t block_idx = first_block + block_in_sector;

            // Re-authenticate every 2 blocks for stability
            if(block_in_sector > 0 && block_in_sector % 2 == 0) {
                error = mf_classic_poller_sync_auth(
                    app->nfc,
                    first_block,
                    &keys_to_try[key_idx],
                    key_types[key_idx],
                    &auth_context);

                if(error != MfClassicErrorNone) {
                    FURI_LOG_W(TAG, "Re-auth failed at block %zu", block_idx);
                    all_blocks_read = false;
                    miband_logger_log(
                        app->logger, LogLevelError, "Auth failed on sector %zu", sector);

                    break;
                }
            }

            // Read block with retry logic
            bool block_read = false;
            for(int retry = 0; retry < 3 && !block_read; retry++) {
                if(retry > 0) furi_delay_ms(50);

                error = mf_classic_poller_sync_read_block(
                    app->nfc,
                    block_idx,
                    &keys_to_try[key_idx],
                    key_types[key_idx],
                    &app->target_data->block[block_idx]);

                if(error == MfClassicErrorNone) {
                    block_read = true;
                } else if(error != MfClassicErrorTimeout) {
                    break; // Non-timeout error, stop retrying
                }
            }

            if(!block_read) {
                FURI_LOG_E(TAG, "Failed to read block %zu", block_idx);
                all_blocks_read = false;
                break;
            }
        }

        if(all_blocks_read) {
            FURI_BIT_SET(app->target_data->key_a_mask, sector);
            FURI_BIT_SET(app->target_data->key_b_mask, sector);
            // view_port_update(view_dispatcher_get_current_view(app->view_dispatcher));
            furi_delay_ms(10);

            return true;
        }
    }

    FURI_LOG_E(TAG, "Sector %zu: All auth attempts failed", sector);
    return false;
}

/**
 * @brief Read all sectors from Mi Band
 * 
 * Performs sector-by-sector reading with progress updates.
 * 
 * @param app Pointer to MiBandNfcApp instance
 * @return true if all sectors read successfully, false otherwise
 */
static bool miband_verify_read_card(MiBandNfcApp* app) {
    if(!app->is_valid_nfc_data) {
        return false;
    }

    verify_tracker.total_sectors = mf_classic_get_total_sectors_num(app->mf_classic_data->type);

    furi_string_set_str(verify_tracker.current_operation, "Initializing read");
    update_verify_ui(app, "Reading Mi Band");

    mf_classic_reset(app->target_data);
    app->target_data->type = app->mf_classic_data->type;

    bool overall_success = true;

    for(size_t sector = 0; sector < verify_tracker.total_sectors; sector++) {
        verify_tracker.current_sector = sector;

        furi_string_printf(verify_tracker.current_operation, "Reading sector %zu", sector);

        // CHIAMALO PIÙ SPESSO - ogni settore
        update_verify_ui(app, "Reading Mi Band");

        furi_delay_ms(50);

        uint8_t first_block = mf_classic_get_first_block_num_of_sector(sector);
        uint8_t blocks_in_sector = mf_classic_get_blocks_num_in_sector(sector);

        bool sector_success = read_sector_with_keys(app, sector, first_block, blocks_in_sector);

        if(sector_success) {
            verify_tracker.sectors_read++;
            furi_string_printf(verify_tracker.last_result, "Sector %zu OK", sector);
            // AGGIORNA SEMPRE
            update_verify_ui(app, "Reading Mi Band");
            furi_delay_ms(50);
        } else {
            verify_tracker.sectors_failed++;
            overall_success = false;
            furi_string_printf(verify_tracker.error_details, "Sector %zu failed", sector);
            FURI_LOG_E(TAG, "Failed to read sector %zu", sector);
        }
    }

    verify_tracker.current_sector = verify_tracker.total_sectors;
    verify_tracker.reading_complete = true;

    if(overall_success) {
        furi_string_set_str(verify_tracker.current_operation, "Read complete");
        furi_string_printf(
            verify_tracker.last_result, "All %lu sectors read", verify_tracker.sectors_read);
    } else {
        furi_string_printf(verify_tracker.current_operation, "Read incomplete");
        furi_string_printf(
            verify_tracker.last_result, "%lu sectors failed", verify_tracker.sectors_failed);
    }

    update_verify_ui(app, "Read Complete");
    furi_delay_ms(1000);

    return overall_success;
}

/**
 * @brief NFC poller callback for initial card detection
 * 
 * Handles card detection events before we start manual reading.
 * 
 * @param event NFC generic event
 * @param context Pointer to MiBandNfcApp instance
 * @return NfcCommand to continue or stop polling
 */
static NfcCommand miband_verify_reader_callback(NfcGenericEvent event, void* context) {
    MiBandNfcApp* app = context;
    furi_assert(event.protocol == NfcProtocolMfClassic);

    const MfClassicPollerEvent* mfc_event = event.event_data;

    if(mfc_event->type == MfClassicPollerEventTypeCardDetected) {
        furi_string_set_str(verify_tracker.current_operation, "Card detected");
        update_verify_ui(app, "Card Found");
        view_dispatcher_send_custom_event(app->view_dispatcher, MiBandNfcCustomEventCardDetected);

    } else if(mfc_event->type == MfClassicPollerEventTypeRequestMode) {
        mfc_event->data->poller_mode.mode = MfClassicPollerModeRead;
        mf_classic_reset(app->target_data);
        mfc_event->data->poller_mode.data = app->target_data;

    } else if(
        mfc_event->type == MfClassicPollerEventTypeSuccess ||
        mfc_event->type == MfClassicPollerEventTypeFail) {
        view_dispatcher_send_custom_event(app->view_dispatcher, MiBandNfcCustomEventPollerDone);
        return NfcCommandStop;
    }

    return NfcCommandContinue;
}

/**
 * @brief Scene entry point
 * 
 * Initializes verification and starts card detection.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_verify_on_enter(void* context) {
    MiBandNfcApp* app = context;

    if(!app->is_valid_nfc_data) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    verify_tracker_init();
    scene_manager_set_scene_state(
        app->scene_manager, MiBandNfcSceneVerify, MiBandNfcSceneVerifyStateCardSearch);

    popup_reset(app->popup);
    popup_set_header(app->popup, "Verify Data", 64, 2, AlignCenter, AlignTop);
    furi_string_set_str(verify_tracker.current_operation, "Place Mi Band near Flipper");
    update_verify_ui(app, "Verify Data");

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);
    notification_message(app->notifications, &sequence_blink_start_cyan);

    mf_classic_reset(app->target_data);
    app->target_data->type = app->mf_classic_data->type;

    app->poller = nfc_poller_alloc(app->nfc, NfcProtocolMfClassic);
    nfc_poller_start(app->poller, miband_verify_reader_callback, app);
}

/**
 * @brief Scene event handler
 * 
 * Handles card detection and verification completion events.
 * 
 * @param context Pointer to MiBandNfcApp instance
 * @param event Scene manager event
 * @return true if event was consumed, false otherwise
 */
bool miband_nfc_scene_verify_on_event(void* context, SceneManagerEvent event) {
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeCustom) {
        switch(event.event) {
        case MiBandNfcCustomEventCardDetected:
            scene_manager_set_scene_state(
                app->scene_manager, MiBandNfcSceneVerify, MiBandNfcSceneVerifyStateReading);
            furi_string_set_str(verify_tracker.current_operation, "Card detected");
            update_verify_ui(app, "Card Detected");
            consumed = true;
            break;

        case MiBandNfcCustomEventPollerDone:
            if(app->poller) {
                nfc_poller_stop(app->poller);
                nfc_poller_free(app->poller);
                app->poller = NULL;
            }

            scene_manager_set_scene_state(
                app->scene_manager, MiBandNfcSceneVerify, MiBandNfcSceneVerifyStateComparison);

            bool read_success = miband_verify_read_card(app);

            if(!read_success) {
                notification_message(app->notifications, &sequence_error);
                furi_string_set_str(
                    verify_tracker.error_details, "Cannot read Mi Band\nCheck keys or position");
                update_verify_ui(app, "Read Failed");
                furi_delay_ms(3000);
                scene_manager_search_and_switch_to_another_scene(
                    app->scene_manager, MiBandNfcSceneMainMenu);
                consumed = true;
                break;
            }

            furi_string_set_str(verify_tracker.current_operation, "Comparing data");
            update_verify_ui(app, "Comparing Data");
            furi_delay_ms(500);

            bool data_match = true;
            int different_blocks = 0;
            size_t total_blocks = mf_classic_get_total_block_num(app->mf_classic_data->type);

            for(size_t i = 0; i < total_blocks; i++) {
                verify_tracker.blocks_compared++;

                if(i % 16 == 0) {
                    furi_string_printf(
                        verify_tracker.current_operation,
                        "Comparing block %zu/%zu",
                        i,
                        total_blocks);
                    update_verify_ui(app, "Comparing Data");
                }

                if(i == 0) {
                    FURI_LOG_D(TAG, "Skipping Block 0 (UID block)");
                    continue;
                } else if(mf_classic_is_sector_trailer(i)) {
                    FURI_LOG_D(TAG, "Skipping trailer block %zu", i);
                    continue;
                } else {
                    if(memcmp(
                           app->mf_classic_data->block[i].data,
                           app->target_data->block[i].data,
                           16) != 0) {
                        data_match = false;
                        different_blocks++;
                        verify_tracker.blocks_different++;
                        FURI_LOG_W(TAG, "Block %zu differs", i);
                    }
                }
            }

            if(data_match && different_blocks == 0) {
                // SUCCESS
                notification_message(app->notifications, &sequence_success);

                // RESET COMPLETO prima di mostrare popup
                text_box_reset(app->text_box_report);
                dialog_ex_reset(app->dialog_ex);

                popup_reset(app->popup);
                popup_set_header(app->popup, "SUCCESS!", 64, 4, AlignCenter, AlignTop);
                popup_set_text(
                    app->popup, "All data matches!\n\nPress Back", 64, 20, AlignCenter, AlignTop);
                popup_set_icon(app->popup, 32, 28, &I_DolphinSuccess_91x55);
                view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdScanner);
                furi_delay_ms(3000);
                scene_manager_search_and_switch_to_another_scene(
                    app->scene_manager, MiBandNfcSceneMainMenu);

            } else {
                // DIFFERENCES FOUND
                notification_message(app->notifications, &sequence_blink_stop);
                notification_message(app->notifications, &sequence_error);

                // RESET TUTTO PRIMA del dialog
                popup_reset(app->popup);
                text_box_reset(app->text_box_report);

                dialog_ex_reset(app->dialog_ex);
                dialog_ex_set_header(
                    app->dialog_ex, "Differences Found", 64, 0, AlignCenter, AlignTop);

                FuriString* msg =
                    furi_string_alloc_printf("%d data blocks\ndiffer from dump", different_blocks);
                dialog_ex_set_text(
                    app->dialog_ex, furi_string_get_cstr(msg), 64, 28, AlignCenter, AlignCenter);
                furi_string_free(msg);

                dialog_ex_set_left_button_text(app->dialog_ex, "Exit");
                dialog_ex_set_right_button_text(app->dialog_ex, "Details");
                dialog_ex_set_icon(app->dialog_ex, 0, 0, NULL);
                dialog_ex_set_result_callback(app->dialog_ex, verify_dialog_callback);
                dialog_ex_set_context(app->dialog_ex, app);

                view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdDialog);
            }

            consumed = true;
            break;

        case MiBandNfcCustomEventVerifyExit:
            // User sceglie Exit
            scene_manager_search_and_switch_to_another_scene(
                app->scene_manager, MiBandNfcSceneMainMenu);
            consumed = true;
            break;

        case MiBandNfcCustomEventVerifyViewDetails:
            // User sceglie View Details - vai al diff viewer
            scene_manager_next_scene(app->scene_manager, MiBandNfcSceneDiffViewer);
            consumed = true;
            break;

        case MiBandNfcCustomEventPollerFailed:
            notification_message(app->notifications, &sequence_error);
            furi_string_set_str(verify_tracker.error_details, "Card detection failed");
            update_verify_ui(app, "Detection Failed");
            furi_delay_ms(2000);
            scene_manager_search_and_switch_to_another_scene(
                app->scene_manager, MiBandNfcSceneMainMenu);
            consumed = true;
            break;
        }
    } else if(event.type == SceneManagerEventTypeBack) {
        scene_manager_search_and_switch_to_another_scene(
            app->scene_manager, MiBandNfcSceneMainMenu);
        consumed = true;
    }

    return consumed;
}

/**
 * @brief Scene exit handler
 * 
 * Cleans up resources and stops notifications.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_verify_on_exit(void* context) {
    MiBandNfcApp* app = context;

    if(app->poller) {
        nfc_poller_stop(app->poller);
        nfc_poller_free(app->poller);
        app->poller = NULL;
    }

    verify_tracker_free();
    notification_message(app->notifications, &sequence_blink_stop);

    // RESET COMPLETO di tutte le view usate
    popup_reset(app->popup);
    dialog_ex_reset(app->dialog_ex);
    text_box_reset(app->text_box_report);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\miband_nfc_scene_writer.c ----
/**
 * @file miband_nfc_scene_writer.c
 * @brief Mi Band NFC data writing scene
 * 
 * This scene handles writing dump data to the Mi Band NFC chip. It implements
 * a robust writing strategy that:
 * 1. Detects the current state of the Mi Band (magic keys vs original keys)
 * 2. Preserves the UID in Block 0 (which is read-only on most cards)
 * 3. Writes all data blocks and sector trailers
 * 4. Uses appropriate authentication keys (0xFF for magic cards, dump keys for rewrites)
 * 5. Provides real-time progress feedback
 */

#include "miband_nfc_i.h"
#include <nfc/protocols/mf_classic/mf_classic_poller_sync.h>

#define TAG "MiBandNfc"

/**
 * @brief Write all blocks in a sector (excluding Block 0)
 * 
 * Helper function that writes all data blocks and the sector trailer
 * for a given sector. Uses retry logic for reliability.
 * 
 * @param app Pointer to MiBandNfcApp instance
 * @param sector Sector number to write
 * @param first_block First block index of the sector
 * @param blocks_in_sector Number of blocks in the sector
 * @param auth_key Authentication key to use
 * @param key_type Key type (A or B)
 * @return true if all blocks written successfully, false otherwise
 */
static bool write_sector_blocks(
    MiBandNfcApp* app,
    size_t sector,
    uint8_t first_block,
    uint8_t blocks_in_sector,
    MfClassicKey* auth_key,
    MfClassicKeyType key_type) {
    MfClassicError error;
    MfClassicAuthContext auth_context;

    // Write all data blocks (excluding the trailer)
    for(uint8_t block_in_sector = 0; block_in_sector < (blocks_in_sector - 1); block_in_sector++) {
        size_t block_idx = first_block + block_in_sector;

        // Re-authenticate before each block (except first)
        if(block_in_sector > 0) {
            error = mf_classic_poller_sync_auth(
                app->nfc, first_block, auth_key, key_type, &auth_context);
            if(error != MfClassicErrorNone) {
                FURI_LOG_E(TAG, "Re-auth failed for block %zu", block_idx);
                miband_logger_log(app->logger, LogLevelError, "Auth failed on sector %zu", sector);

                return false;
            }
        }

        // Write block with retry logic (up to 3 attempts)
        bool block_written = false;
        for(int retry = 0; retry < 3 && !block_written; retry++) {
            if(retry > 0) furi_delay_ms(100); // Delay between retries

            error = mf_classic_poller_sync_write_block(
                app->nfc, block_idx, auth_key, key_type, &app->mf_classic_data->block[block_idx]);

            if(error == MfClassicErrorNone) {
                block_written = true;
            } else if(error != MfClassicErrorTimeout) {
                break; // Non-timeout error, stop retrying
            }
        }

        if(!block_written) {
            FURI_LOG_E(TAG, "Failed to write block %zu", block_idx);
            return false;
        }
    }

    // Write the sector trailer
    size_t trailer_idx = first_block + blocks_in_sector - 1;
    bool trailer_written = false;

    for(int retry = 0; retry < 3 && !trailer_written; retry++) {
        if(retry > 0) {
            furi_delay_ms(100);
            // Re-authenticate before retry
            error = mf_classic_poller_sync_auth(
                app->nfc, first_block, auth_key, key_type, &auth_context);
            if(error != MfClassicErrorNone) {
                FURI_LOG_E(TAG, "Re-auth failed for trailer");
                miband_logger_log(app->logger, LogLevelError, "Auth failed on sector %zu", sector);

                return false;
            }
        }

        error = mf_classic_poller_sync_write_block(
            app->nfc, trailer_idx, auth_key, key_type, &app->mf_classic_data->block[trailer_idx]);

        if(error == MfClassicErrorNone) {
            trailer_written = true;
        } else if(error != MfClassicErrorTimeout) {
            break; // Non-timeout error, stop retrying
        }
    }

    if(!trailer_written) {
        FURI_LOG_E(TAG, "Failed to write trailer at block %zu", trailer_idx);
        return false;
    }

    FURI_LOG_I(TAG, "Sector %zu: Write SUCCESS", sector);
    return true;
}

/**
 * @brief Main write function using synchronous approach
 * 
 * This function implements a robust writing strategy:
 * 1. Detects card state (magic keys or original keys)
 * 2. Preserves Block 0 UID
 * 3. Writes all sectors with appropriate authentication
 * 4. Provides progress feedback
 * 
 * @param app Pointer to MiBandNfcApp instance
 * @return true if write successful, false otherwise
 */
static bool miband_write_with_sync_approach(MiBandNfcApp* app) {
    if(!app->is_valid_nfc_data) {
        return false;
    }

    // NON usare popup_reset qui - è già stato fatto in on_enter
    popup_set_text(app->popup, "Detecting card state...", 64, 24, AlignCenter, AlignTop);
    furi_delay_ms(100);

    MfClassicError error = MfClassicErrorNone;
    bool write_success = true;
    size_t total_blocks = mf_classic_get_total_block_num(app->mf_classic_data->type);
    size_t total_sectors = mf_classic_get_total_sectors_num(app->mf_classic_data->type);

    FURI_LOG_I(
        TAG, "Starting sync write for %zu blocks in %zu sectors", total_blocks, total_sectors);

    MfClassicType type = MfClassicType1k;
    MfClassicError detect_error = mf_classic_poller_sync_detect_type(app->nfc, &type);
    if(detect_error != MfClassicErrorNone) {
        FURI_LOG_E(TAG, "Card detection failed before write: %d", detect_error);
        popup_set_text(
            app->popup, "Card not detected\nCheck position", 64, 24, AlignCenter, AlignTop);
        furi_delay_ms(2000);
        return false;
    }

    FURI_LOG_I(TAG, "Card detected successfully, type: %d", type);

    bool has_magic_keys = false;
    MfClassicKey test_key = {0};
    memset(test_key.data, 0xFF, sizeof(test_key.data));
    MfClassicAuthContext test_auth;

    MfClassicError test_error =
        mf_classic_poller_sync_auth(app->nfc, 4, &test_key, MfClassicKeyTypeA, &test_auth);

    if(test_error == MfClassicErrorNone) {
        has_magic_keys = true;
        FURI_LOG_I(TAG, "Mi Band has 0xFF keys - first write scenario");
        popup_set_text(
            app->popup, "Magic keys detected\nWriting...", 64, 24, AlignCenter, AlignTop);
    } else {
        FURI_LOG_I(TAG, "Mi Band has dump keys - rewrite scenario");
        popup_set_text(
            app->popup, "Original keys detected\nRewriting...", 64, 24, AlignCenter, AlignTop);
    }

    furi_delay_ms(1000);

    for(size_t sector = 0; sector < total_sectors; sector++) {
        FURI_LOG_I(TAG, "Processing sector %zu...", sector);

        FuriString* progress_msg = furi_string_alloc();
        furi_string_printf(progress_msg, "Sector %zu/%zu\n\n", sector + 1, total_sectors);

        uint32_t progress_percent = ((sector + 1) * 100) / total_sectors;
        furi_string_cat_str(progress_msg, "[");
        for(uint8_t i = 0; i < 20; i++) {
            if(i < (progress_percent / 5)) {
                furi_string_cat_str(progress_msg, "=");
            } else if(i == (progress_percent / 5)) {
                furi_string_cat_str(progress_msg, ">");
            } else {
                furi_string_cat_str(progress_msg, " ");
            }
        }
        furi_string_cat_printf(progress_msg, "]\n%lu%%", progress_percent);

        // SOLO text update, NO reset
        popup_set_text(
            app->popup, furi_string_get_cstr(progress_msg), 64, 18, AlignCenter, AlignTop);
        furi_string_free(progress_msg);

        furi_delay_ms(100);

        uint8_t first_block = mf_classic_get_first_block_num_of_sector(sector);
        uint8_t blocks_in_sector = mf_classic_get_blocks_num_in_sector(sector);
        bool sector_written = false;

        MfClassicSectorTrailer* sec_tr =
            mf_classic_get_sector_trailer_by_sector(app->mf_classic_data, sector);
        MfClassicKey auth_key = {0};
        MfClassicKeyType auth_key_type = MfClassicKeyTypeA;
        MfClassicAuthContext auth_context;

        if(sector == 0) {
            FURI_LOG_I(TAG, "Sector 0: Special handling - preserving UID");

            MfClassicBlock current_block0;
            bool block0_read = false;

            memset(auth_key.data, 0xFF, sizeof(auth_key.data));
            error = mf_classic_poller_sync_auth(
                app->nfc, 0, &auth_key, MfClassicKeyTypeA, &auth_context);

            if(error == MfClassicErrorNone) {
                error = mf_classic_poller_sync_read_block(
                    app->nfc, 0, &auth_key, MfClassicKeyTypeA, &current_block0);
                if(error == MfClassicErrorNone) {
                    block0_read = true;
                    FURI_LOG_I(TAG, "Block 0 read with 0xFF keys");
                }
            }

            if(!block0_read &&
               mf_classic_is_key_found(app->mf_classic_data, 0, MfClassicKeyTypeA)) {
                memcpy(auth_key.data, sec_tr->key_a.data, sizeof(auth_key.data));
                error = mf_classic_poller_sync_auth(
                    app->nfc, 0, &auth_key, MfClassicKeyTypeA, &auth_context);

                if(error == MfClassicErrorNone) {
                    error = mf_classic_poller_sync_read_block(
                        app->nfc, 0, &auth_key, MfClassicKeyTypeA, &current_block0);
                    if(error == MfClassicErrorNone) {
                        block0_read = true;
                        FURI_LOG_I(TAG, "Block 0 read with dump Key A");
                    }
                }
            }

            if(!block0_read &&
               mf_classic_is_key_found(app->mf_classic_data, 0, MfClassicKeyTypeB)) {
                memcpy(auth_key.data, sec_tr->key_b.data, sizeof(auth_key.data));
                error = mf_classic_poller_sync_auth(
                    app->nfc, 0, &auth_key, MfClassicKeyTypeB, &auth_context);

                if(error == MfClassicErrorNone) {
                    error = mf_classic_poller_sync_read_block(
                        app->nfc, 0, &auth_key, MfClassicKeyTypeB, &current_block0);
                    if(error == MfClassicErrorNone) {
                        block0_read = true;
                        auth_key_type = MfClassicKeyTypeB;
                        FURI_LOG_I(TAG, "Block 0 read with dump Key B");
                    }
                }
            }

            if(!block0_read) {
                FURI_LOG_E(TAG, "CRITICAL: Cannot read Block 0!");
                write_success = false;
                break;
            }

            FURI_LOG_I(
                TAG,
                "Block 0 preserved: UID %02X%02X%02X%02X",
                current_block0.data[0],
                current_block0.data[1],
                current_block0.data[2],
                current_block0.data[3]);

            FURI_LOG_D(TAG, "Writing sector 0 data blocks (1 and 2)");

            for(uint8_t block_in_sector = 1; block_in_sector < (blocks_in_sector - 1);
                block_in_sector++) {
                size_t block_idx = first_block + block_in_sector;

                if(block_in_sector > 1) {
                    error = mf_classic_poller_sync_auth(
                        app->nfc, first_block, &auth_key, auth_key_type, &auth_context);
                    if(error != MfClassicErrorNone) {
                        FURI_LOG_E(TAG, "Re-auth failed for block %zu", block_idx);
                        miband_logger_log(
                            app->logger, LogLevelError, "Auth failed on sector %zu", sector);

                        write_success = false;
                        break;
                    }
                }

                bool block_written = false;
                for(int retry = 0; retry < 3 && !block_written; retry++) {
                    if(retry > 0) furi_delay_ms(100);

                    error = mf_classic_poller_sync_write_block(
                        app->nfc,
                        block_idx,
                        &auth_key,
                        auth_key_type,
                        &app->mf_classic_data->block[block_idx]);

                    if(error == MfClassicErrorNone) {
                        block_written = true;
                        FURI_LOG_D(TAG, "Block %zu written (retry %d)", block_idx, retry);
                    } else if(error != MfClassicErrorTimeout) {
                        break;
                    }
                }

                if(!block_written) {
                    FURI_LOG_E(TAG, "Failed to write block %zu", block_idx);
                    write_success = false;
                    break;
                }
            }

            if(write_success) {
                size_t trailer_idx = first_block + blocks_in_sector - 1;
                FURI_LOG_D(TAG, "Writing sector 0 trailer block %zu", trailer_idx);

                bool trailer_written = false;
                for(int retry = 0; retry < 3 && !trailer_written; retry++) {
                    if(retry > 0) {
                        furi_delay_ms(100);
                        error = mf_classic_poller_sync_auth(
                            app->nfc, first_block, &auth_key, auth_key_type, &auth_context);
                        if(error != MfClassicErrorNone) break;
                    }

                    error = mf_classic_poller_sync_write_block(
                        app->nfc,
                        trailer_idx,
                        &auth_key,
                        auth_key_type,
                        &app->mf_classic_data->block[trailer_idx]);

                    if(error == MfClassicErrorNone) {
                        trailer_written = true;
                        sector_written = true;
                        FURI_LOG_I(TAG, "Sector 0 trailer written (retry %d)", retry);
                    } else if(error != MfClassicErrorTimeout) {
                        break;
                    }
                }

                if(!trailer_written) {
                    FURI_LOG_E(TAG, "Failed to write sector 0 trailer");
                    write_success = false;
                }
            }

            continue;
        }

        if(has_magic_keys) {
            memset(auth_key.data, 0xFF, sizeof(auth_key.data));
            error = mf_classic_poller_sync_auth(
                app->nfc, first_block, &auth_key, MfClassicKeyTypeA, &auth_context);

            if(error == MfClassicErrorNone) {
                FURI_LOG_I(TAG, "Sector %zu: Auth with 0xFF", sector);
                sector_written = write_sector_blocks(
                    app, sector, first_block, blocks_in_sector, &auth_key, MfClassicKeyTypeA);
            }
        }

        if(!sector_written) {
            if(mf_classic_is_key_found(app->mf_classic_data, sector, MfClassicKeyTypeA)) {
                memcpy(auth_key.data, sec_tr->key_a.data, sizeof(auth_key.data));

                for(int retry = 0; retry < 2 && !sector_written; retry++) {
                    if(retry > 0) furi_delay_ms(200);

                    error = mf_classic_poller_sync_auth(
                        app->nfc, first_block, &auth_key, MfClassicKeyTypeA, &auth_context);

                    if(error == MfClassicErrorNone) {
                        FURI_LOG_I(TAG, "Sector %zu: Auth with dump Key A", sector);
                        sector_written = write_sector_blocks(
                            app,
                            sector,
                            first_block,
                            blocks_in_sector,
                            &auth_key,
                            MfClassicKeyTypeA);
                        break;
                    }
                }
            }

            if(!sector_written &&
               mf_classic_is_key_found(app->mf_classic_data, sector, MfClassicKeyTypeB)) {
                memcpy(auth_key.data, sec_tr->key_b.data, sizeof(auth_key.data));

                for(int retry = 0; retry < 2 && !sector_written; retry++) {
                    if(retry > 0) furi_delay_ms(200);

                    error = mf_classic_poller_sync_auth(
                        app->nfc, first_block, &auth_key, MfClassicKeyTypeB, &auth_context);

                    if(error == MfClassicErrorNone) {
                        FURI_LOG_I(TAG, "Sector %zu: Auth with dump Key B", sector);
                        sector_written = write_sector_blocks(
                            app,
                            sector,
                            first_block,
                            blocks_in_sector,
                            &auth_key,
                            MfClassicKeyTypeB);
                        break;
                    }
                }
            }

            if(!sector_written && !has_magic_keys) {
                FURI_LOG_W(TAG, "Sector %zu: Trying 0xFF as last resort", sector);
                memset(auth_key.data, 0xFF, sizeof(auth_key.data));
                error = mf_classic_poller_sync_auth(
                    app->nfc, first_block, &auth_key, MfClassicKeyTypeA, &auth_context);

                if(error == MfClassicErrorNone) {
                    sector_written = write_sector_blocks(
                        app, sector, first_block, blocks_in_sector, &auth_key, MfClassicKeyTypeA);
                }
            }
        }

        if(!sector_written) {
            FURI_LOG_E(TAG, "Sector %zu: ALL authentication methods FAILED", sector);
            write_success = false;
            break;
        }
    }

    FURI_LOG_I(TAG, "Sync write completed: %s", write_success ? "SUCCESS" : "FAILED");
    return write_success;
}

/**
 * @brief Scanner callback for card detection
 * 
 * Called when NFC scanner detects a card. Validates that it's a
 * Mifare Classic card before proceeding to write.
 * 
 * @param event NFC scanner event
 * @param context Pointer to MiBandNfcApp instance
 */
static void miband_nfc_scene_writer_scan_callback(NfcScannerEvent event, void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(event.type == NfcScannerEventTypeDetected) {
        // Log all detected protocols for debugging
        FURI_LOG_D(TAG, "Card detected with %zu protocols:", event.data.protocol_num);
        for(size_t i = 0; i < event.data.protocol_num; i++) {
            FURI_LOG_D(TAG, "  Protocol %zu: %d", i, event.data.protocols[i]);
        }

        // Check if Mifare Classic is among detected protocols
        bool has_mf_classic = false;
        for(size_t i = 0; i < event.data.protocol_num; i++) {
            if(event.data.protocols[i] == NfcProtocolMfClassic) {
                has_mf_classic = true;
                FURI_LOG_I(TAG, "MfClassic found at index %zu", i);
                break;
            }
        }

        if(has_mf_classic) {
            FURI_LOG_I(TAG, "Mi Band valid for write operation");
            view_dispatcher_send_custom_event(
                app->view_dispatcher, MiBandNfcCustomEventCardDetected);
        } else {
            FURI_LOG_W(TAG, "No MfClassic protocol found");
            view_dispatcher_send_custom_event(app->view_dispatcher, MiBandNfcCustomEventWrongCard);
        }
    }
}

/**
 * @brief Scene entry point
 * 
 * Initializes scanner and waits for Mi Band to be placed near Flipper.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_writer_on_enter(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(!app->is_valid_nfc_data) {
        scene_manager_previous_scene(app->scene_manager);
        return;
    }

    popup_reset(app->popup);

    if(app->current_operation == OperationTypeWriteOriginal) {
        popup_set_header(app->popup, "Write Original Data", 64, 4, AlignCenter, AlignTop);
    } else {
        popup_set_header(app->popup, "Write Data", 64, 4, AlignCenter, AlignTop);
    }

    popup_set_text(
        app->popup,
        "Place Mi Band near\nthe Flipper Zero\n\nWaiting for card...",
        64,
        20,
        AlignCenter,
        AlignTop);

    view_dispatcher_switch_to_view(app->view_dispatcher, MiBandNfcViewIdWriter);
    notification_message(app->notifications, &sequence_blink_start_cyan);

    app->poller = NULL;
    app->scanner = nfc_scanner_alloc(app->nfc);
    nfc_scanner_start(app->scanner, miband_nfc_scene_writer_scan_callback, app);
    app->is_scan_active = true;

    FURI_LOG_I(TAG, "Waiting for Mi Band to be placed...");
}

/**
 * @brief Scene event handler
 * 
 * Handles card detection and write completion events.
 * 
 * @param context Pointer to MiBandNfcApp instance
 * @param event Scene manager event
 * @return true if event was consumed, false otherwise
 */
bool miband_nfc_scene_writer_on_event(void* context, SceneManagerEvent event) {
    furi_assert(context);
    MiBandNfcApp* app = context;
    bool consumed = false;

    if(event.type == SceneManagerEventTypeCustom) {
        switch(event.event) {
        case MiBandNfcCustomEventCardDetected:
            if(app->scanner) {
                nfc_scanner_stop(app->scanner);
                nfc_scanner_free(app->scanner);
                app->scanner = NULL;
                app->is_scan_active = false;
            }

            popup_reset(app->popup);
            popup_set_header(app->popup, "Writing Data", 64, 4, AlignCenter, AlignTop);

            popup_set_text(app->popup, "Starting write...", 64, 18, AlignCenter, AlignTop);
            furi_delay_ms(500);

            miband_logger_log(
                app->logger,
                LogLevelInfo,
                "Write started: %s",
                furi_string_get_cstr(app->file_path));

            notification_message(app->notifications, &sequence_blink_stop);
            notification_message(app->notifications, &sequence_blink_start_magenta);

            FURI_LOG_I(TAG, "Starting write operation");
            bool write_result = miband_write_with_sync_approach(app);

            popup_reset(app->popup);

            if(write_result) {
                notification_message(app->notifications, &sequence_success);
                popup_set_header(app->popup, "Write Success!", 64, 4, AlignCenter, AlignTop);
                popup_set_text(
                    app->popup, "Data written\nsuccessfully", 64, 20, AlignCenter, AlignTop);
                popup_set_icon(app->popup, 32, 24, &I_DolphinSuccess_91x55);
                furi_delay_ms(2000);

                if(app->verify_after_write) {
                    popup_set_text(app->popup, "Auto-verifying...", 64, 20, AlignCenter, AlignTop);
                    furi_delay_ms(500);
                    scene_manager_next_scene(app->scene_manager, MiBandNfcSceneVerify);
                } else {
                    scene_manager_search_and_switch_to_another_scene(
                        app->scene_manager, MiBandNfcSceneMainMenu);
                }
            } else {
                notification_message(app->notifications, &sequence_error);
                popup_set_header(app->popup, "Write Failed", 64, 4, AlignCenter, AlignTop);
                popup_set_text(
                    app->popup,
                    "Could not write\ndata to Mi Band\n\nCheck position",
                    64,
                    20,
                    AlignCenter,
                    AlignTop);
                popup_set_icon(app->popup, 40, 28, &I_WarningDolphinFlip_45x42);
                FURI_LOG_E(TAG, "Write failed");
            }

            furi_delay_ms(3000);
            scene_manager_search_and_switch_to_another_scene(
                app->scene_manager, MiBandNfcSceneMainMenu);
            consumed = true;
            break;

        case MiBandNfcCustomEventWrongCard:
            if(app->scanner) {
                nfc_scanner_stop(app->scanner);
                nfc_scanner_free(app->scanner);
                app->scanner = NULL;
                app->is_scan_active = false;
            }

            popup_set_header(app->popup, "Wrong Card Type", 64, 4, AlignCenter, AlignTop);
            popup_set_text(
                app->popup,
                "This is not a\nMifare Classic card\n\nTry again",
                64,
                20,
                AlignCenter,
                AlignTop);
            popup_set_icon(app->popup, 40, 28, &I_WarningDolphinFlip_45x42);
            notification_message(app->notifications, &sequence_error);

            furi_delay_ms(2000);
            scene_manager_search_and_switch_to_another_scene(
                app->scene_manager, MiBandNfcSceneMainMenu);
            consumed = true;
            break;

        default:
            break;
        }
    } else if(event.type == SceneManagerEventTypeBack) {
        scene_manager_search_and_switch_to_another_scene(
            app->scene_manager, MiBandNfcSceneMainMenu);
        consumed = true;
    }

    return consumed;
}
/**
 * @brief Scene exit handler
 * 
 * Stops scanner if active and cleans up resources.
 * 
 * @param context Pointer to MiBandNfcApp instance
 */
void miband_nfc_scene_writer_on_exit(void* context) {
    furi_assert(context);
    MiBandNfcApp* app = context;

    if(app->scanner) {
        nfc_scanner_stop(app->scanner);
        nfc_scanner_free(app->scanner);
        app->scanner = NULL;
    }
    app->is_scan_active = false;

    notification_message(app->notifications, &sequence_blink_stop);
    popup_reset(app->popup);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\progress_tracker.c ----
/**
 * @file progress_tracker.c
 * @brief Progress tracker implementation
 */

#include "progress_tracker.h"
#include <furi_hal_rtc.h>

/**
 * @brief Progress tracker internal structure
 */
struct ProgressTracker {
    uint32_t total_items;
    uint32_t completed_items;
    char operation_name[32];
    uint32_t start_time;
    uint32_t last_update_time;
};

ProgressTracker* progress_tracker_alloc(uint32_t total_items, const char* operation_name) {
    ProgressTracker* tracker = malloc(sizeof(ProgressTracker));

    tracker->total_items = total_items;
    tracker->completed_items = 0;
    tracker->start_time = furi_get_tick();
    tracker->last_update_time = tracker->start_time;

    strncpy(tracker->operation_name, operation_name, 31);
    tracker->operation_name[31] = '\0';

    return tracker;
}

void progress_tracker_free(ProgressTracker* tracker) {
    free(tracker);
}

void progress_tracker_update(ProgressTracker* tracker, uint32_t completed_items) {
    tracker->completed_items = completed_items;
    tracker->last_update_time = furi_get_tick();
}

void progress_tracker_increment(ProgressTracker* tracker) {
    tracker->completed_items++;
    tracker->last_update_time = furi_get_tick();
}

uint8_t progress_tracker_get_percentage(const ProgressTracker* tracker) {
    if(tracker->total_items == 0) return 0;
    return (tracker->completed_items * 100) / tracker->total_items;
}

FuriString* progress_tracker_get_text(const ProgressTracker* tracker) {
    FuriString* text = furi_string_alloc();
    uint8_t percentage = progress_tracker_get_percentage(tracker);

    furi_string_printf(
        text,
        "%s: %lu/%lu (%u%%)",
        tracker->operation_name,
        tracker->completed_items,
        tracker->total_items,
        percentage);

    return text;
}

FuriString* progress_tracker_get_bar(const ProgressTracker* tracker, uint8_t width) {
    FuriString* bar = furi_string_alloc();
    uint8_t percentage = progress_tracker_get_percentage(tracker);
    uint8_t filled = (percentage * width) / 100;

    furi_string_cat_str(bar, "[");
    for(uint8_t i = 0; i < width; i++) {
        if(i < filled) {
            furi_string_cat_str(bar, "=");
        } else if(i == filled && percentage < 100) {
            furi_string_cat_str(bar, ">");
        } else {
            furi_string_cat_str(bar, " ");
        }
    }
    furi_string_cat_str(bar, "]");

    return bar;
}

uint32_t progress_tracker_get_eta_seconds(const ProgressTracker* tracker) {
    if(tracker->completed_items == 0) return 0;

    uint32_t elapsed_ms = furi_get_tick() - tracker->start_time;
    uint32_t ms_per_item = elapsed_ms / tracker->completed_items;
    uint32_t remaining_items = tracker->total_items - tracker->completed_items;
    uint32_t eta_ms = ms_per_item * remaining_items;

    return eta_ms / 1000; // Convert to seconds
}

void progress_tracker_update_popup(
    const ProgressTracker* tracker,
    Popup* popup,
    const char* header) {
    if(header) {
        popup_set_header(popup, header, 64, 2, AlignCenter, AlignTop);
    }

    FuriString* text = furi_string_alloc();

    // Progress text
    FuriString* progress_text = progress_tracker_get_text(tracker);
    furi_string_cat(text, progress_text);
    furi_string_free(progress_text);

    furi_string_cat_str(text, "\n\n");

    // Progress bar
    FuriString* bar = progress_tracker_get_bar(tracker, 20);
    furi_string_cat(text, bar);
    furi_string_free(bar);

    // ETA if available
    uint32_t eta = progress_tracker_get_eta_seconds(tracker);
    if(eta > 0 && tracker->completed_items > 5) {
        furi_string_cat_printf(text, "\n\nETA: %lu seconds", eta);
    }

    popup_set_text(popup, furi_string_get_cstr(text), 4, 18, AlignLeft, AlignTop);

    furi_string_free(text);
}
---- File: C:\Users\luca.tomei\Downloads\DEV\PERSONALE\flipper-miband-nfc-writer\progress_tracker.h ----
/**
 * @file progress_tracker.h
 * @brief Progress tracking utility for long operations
 * 
 * This module provides a reusable progress tracker that can be used
 * across different scenes to show detailed progress information with
 * percentage, progress bar, and estimated time remaining.
 */

#pragma once

#include <furi.h>
#include <gui/modules/popup.h>

/**
 * @brief Progress tracker structure
 */
typedef struct ProgressTracker ProgressTracker;

/**
 * @brief Create a new progress tracker
 * 
 * @param total_items Total number of items to process
 * @param operation_name Name of the operation (e.g., "Writing")
 * @return Allocated ProgressTracker instance
 */
ProgressTracker* progress_tracker_alloc(uint32_t total_items, const char* operation_name);

/**
 * @brief Free progress tracker
 * 
 * @param tracker Progress tracker instance
 */
void progress_tracker_free(ProgressTracker* tracker);

/**
 * @brief Update progress
 * 
 * @param tracker Progress tracker instance
 * @param completed_items Number of completed items
 */
void progress_tracker_update(ProgressTracker* tracker, uint32_t completed_items);

/**
 * @brief Increment progress by one item
 * 
 * @param tracker Progress tracker instance
 */
void progress_tracker_increment(ProgressTracker* tracker);

/**
 * @brief Get current progress percentage
 * 
 * @param tracker Progress tracker instance
 * @return Progress percentage (0-100)
 */
uint8_t progress_tracker_get_percentage(const ProgressTracker* tracker);

/**
 * @brief Get formatted progress string
 * 
 * Generates a string like: "Writing: 45/64 blocks (70%)"
 * 
 * @param tracker Progress tracker instance
 * @return Allocated FuriString with progress text
 */
FuriString* progress_tracker_get_text(const ProgressTracker* tracker);

/**
 * @brief Get progress bar string
 * 
 * Generates ASCII progress bar like: "[=======>   ]"
 * 
 * @param tracker Progress tracker instance
 * @param width Width of progress bar in characters
 * @return Allocated FuriString with progress bar
 */
FuriString* progress_tracker_get_bar(const ProgressTracker* tracker, uint8_t width);

/**
 * @brief Get estimated time remaining
 * 
 * @param tracker Progress tracker instance
 * @return Estimated seconds remaining, or 0 if unknown
 */
uint32_t progress_tracker_get_eta_seconds(const ProgressTracker* tracker);

/**
 * @brief Update popup with progress information
 * 
 * Convenience function to update a popup view with complete progress info.
 * 
 * @param tracker Progress tracker instance
 * @param popup Popup view to update
 * @param header Optional header text (NULL to keep current)
 */
void progress_tracker_update_popup(
    const ProgressTracker* tracker,
    Popup* popup,
    const char* header);
